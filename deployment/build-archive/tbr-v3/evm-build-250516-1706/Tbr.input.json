{
  "language": "Solidity",
  "sources": {
    "src/Tbr.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {ITokenBridge} from \"wormhole-sdk/interfaces/ITokenBridge.sol\";\nimport {IWETH} from \"wormhole-sdk/interfaces/token/IWETH.sol\";\nimport {IPermit2} from \"permit2/IPermit2.sol\";\nimport {TbrDispatcher} from \"./assets/TbrDispatcher.sol\";\nimport {TbrBase} from \"./assets/TbrBase.sol\";\n\ncontract Tbr is TbrDispatcher {\n  using BytesParsing for bytes;\n\n  constructor(\n    IPermit2 initPermit2,\n    ITokenBridge initTokenBridge,\n    address oracle,\n    IWETH initGasToken,\n    bool initGasErc20TokenizationIsExplicit\n  ) TbrBase(\n    initPermit2,\n    initTokenBridge,\n    oracle,\n    initGasToken,\n    initGasErc20TokenizationIsExplicit\n  ) {}\n\n  //constructor of the proxy contract setting storage variables\n  function _proxyConstructor(bytes calldata args) internal override {\n    uint offset = 0;\n\n    address feeRecipient;\n    address owner;\n    (feeRecipient, offset) = args.asAddressCdUnchecked(offset);\n    (owner,        offset) = args.asAddressCdUnchecked(offset);\n    uint8 adminCount;\n    (adminCount,   offset) = args.asUint8CdUnchecked(offset);\n    address[] memory admins = new address[](adminCount);\n    for (uint i = 0; i < adminCount; ++i) {\n      (admins[i],  offset) = args.asAddressCdUnchecked(offset);\n    }\n\n    BytesParsing.checkLength(offset, args.length);\n\n    _accessControlConstruction(owner, admins);\n    _configConstruction(payable(feeRecipient));\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/libraries/BytesParsing.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.4;\n\nimport \"wormhole-sdk/constants/Common.sol\";\n\n//This file appears comically large, but all unused functions are removed by the compiler.\nlibrary BytesParsing {\n  error OutOfBounds(uint256 offset, uint256 length);\n  error LengthMismatch(uint256 encodedLength, uint256 expectedLength);\n  error InvalidBoolVal(uint8 val);\n\n  /**\n   * Implements runtime check of logic that accesses memory.\n   * @param pastTheEndOffset The offset past the end relative to the accessed memory fragment.\n   * @param length The length of the memory fragment accessed.\n   */\n  function checkBound(uint pastTheEndOffset, uint length) internal pure {\n    if (pastTheEndOffset > length)\n      revert OutOfBounds(pastTheEndOffset, length);\n  }\n\n  function checkLength(uint encodedLength, uint expectedLength) internal pure {\n    if (encodedLength != expectedLength)\n      revert LengthMismatch(encodedLength, expectedLength);\n  }\n\n  //Summary of all remaining functions:\n  //\n  //Each function has 2*2=4 versions:\n  //  1. unchecked - no bounds checking (uses suffix `Unchecked`)\n  //  2. checked (no suffix)\n  //and (since Solidity does not allow overloading based on data location)\n  //  1. calldata input (uses tag `Cd` )\n  //  2. memory input (uses tag `Mem`)\n  //\n  //The canoncial/recommended way of parsing data to be maximally gas efficient is to prefer the\n  //  calldata variants over the memory variants and to use the unchecked variants with a manual\n  //  length check at the end using `checkLength` to ensure that encoded data was consumed exactly.\n  //\n  //WARNING: Neither variant uses safe math! It is up to the dev to ensure that offset and length\n  //  values are sensible. In other words, verify user inputs before passing them on. Preferably,\n  //  the format that's being parsed does not allow for such overflows in the first place by e.g.\n  //  encoding lengths using at most 4 bytes, etc.\n  //\n  //Functions:\n  //  Unless stated otherwise, all functions take an `encoded` bytes calldata/memory and an `offset`\n  //    as input and return the parsed value and the next offset (i.e. the offset pointing to the\n  //    next, unparsed byte).\n  //\n  // * slice(encoded, offset, length)\n  // * sliceUint<n>Prefixed - n in {8, 16, 32} - parses n bytes of length prefix followed by data\n  // * asAddress\n  // * asBool\n  // * asUint<8*n> - n in {1, ..., 32}, i.e. asUint8, asUint16, ..., asUint256\n  // * asBytes<n>  - n in {1, ..., 32}, i.e. asBytes1, asBytes2, ..., asBytes32\n\n  function sliceCdUnchecked(\n    bytes calldata encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret.offset := add(encoded.offset, offset)\n      ret.length := length\n      nextOffset := add(offset, length)\n    }\n  }\n\n  function sliceMemUnchecked(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, length)\n      ret := mload(FREE_MEMORY_PTR)\n\n      //Explanation on how we copy data here:\n      //  The bytes type has the following layout in memory:\n      //    [length: 32 bytes, data: length bytes]\n      //  So if we allocate `bytes memory foo = new bytes(1);` then `foo` will be a pointer to 33\n      //    bytes where the first 32 bytes contain the length and the last byte is the actual data.\n      //  Since mload always loads 32 bytes of memory at once, we use our shift variable to align\n      //    our reads so that our last read lines up exactly with the last 32 bytes of `encoded`.\n      //  However this also means that if the length of `encoded` is not a multiple of 32 bytes, our\n      //    first read will necessarily partly contain bytes from `encoded`'s 32 length bytes that\n      //    will be written into the length part of our `ret` slice.\n      //  We remedy this issue by writing the length of our `ret` slice at the end, thus\n      //    overwritting those garbage bytes.\n\n      //and(length, 31) is equivalent to `mod(length, 32)`, but 2 gas cheaper\n      let shift := and(length, WORD_SIZE_MINUS_ONE)\n      if iszero(shift) {\n        shift := WORD_SIZE\n      }\n\n      let dest := add(ret, shift)\n      let end := add(dest, length)\n      for {\n        let src := add(add(encoded, shift), offset)\n      } lt(dest, end) {\n        src := add(src, WORD_SIZE)\n        dest := add(dest, WORD_SIZE)\n      } {\n        mstore(dest, mload(src))\n      }\n\n      mstore(ret, length)\n      //When compiling with --via-ir then normally allocated memory (i.e. via new) will have 32 byte\n      //  memory alignment and so we enforce the same memory alignment here.\n      mstore(\n        FREE_MEMORY_PTR,\n        and(add(dest, WORD_SIZE_MINUS_ONE), not(WORD_SIZE_MINUS_ONE))\n      )\n    }\n  }\n\n/* -------------------------------------------------------------------------------------------------\nRemaining library code below was auto-generated via the following js/node code:\n\nconst dlTag = dl => dl ? \"Cd\" : \"Mem\";\nconst dlType = dl =>dl ? \"calldata\" : \"memory\";\n\nconst funcs = [\n  ...[8,16,32].map(n => [\n    `sliceUint${n}Prefixed`,\n    dl => [\n      `uint${n} len;`,\n      `(len, nextOffset) = asUint${n}${dlTag(dl)}Unchecked(encoded, offset);`,\n      `(ret, nextOffset) = slice${dlTag(dl)}Unchecked(encoded, nextOffset, uint(len));`\n    ],\n    dl => `bytes ${dlType(dl)}`,\n  ]), [\n    `asAddress`,\n    dl => [\n      `uint160 tmp;`,\n      `(tmp, nextOffset) = asUint160${dlTag(dl)}Unchecked(encoded, offset);`,\n      `ret = address(tmp);`\n    ],\n    _ => `address`\n  ], [\n    `asBool`,\n    dl => [\n      `uint8 val;`,\n      `(val, nextOffset) = asUint8${dlTag(dl)}Unchecked(encoded, offset);`,\n      `if (val & 0xfe != 0)`,\n      `  revert InvalidBoolVal(val);`,\n      `uint cleanedVal = uint(val);`,\n      `//skip 2x iszero opcode`,\n      `/// @solidity memory-safe-assembly`,\n      `assembly { ret := cleanedVal }`\n    ],\n    _ => `bool`\n  ],\n  ...Array.from({length: 32}, (_, i) => [\n    `asUint${(i+1)*8}`,\n    dl => [\n      `/// @solidity memory-safe-assembly`,\n      `assembly {`,\n      `  nextOffset := add(offset, ${i+1})`,\n      dl ? `  ret := shr(${256-(i+1)*8}, calldataload(add(encoded.offset, offset)))`\n         : `  ret := mload(add(encoded, nextOffset))`,\n      `}`\n    ],\n    _ => `uint${(i+1)*8}`\n  ]),\n  ...Array.from({length: 32}, (_, i) => [\n    `asBytes${i+1}`,\n    dl => [\n      `/// @solidity memory-safe-assembly`,\n      `assembly {`,\n      `  ret := ${dl ? \"calldataload\" : \"mload\"}(add(encoded${dl ? \".offset\" :\"\"}, ${dl ? \"offset\" : \"add(offset, WORD_SIZE)\"}))`,\n      `  nextOffset := add(offset, ${i+1})`,\n      `}`\n    ],\n    _ => `bytes${i+1}`\n  ]),\n];\n\nfor (const dl of [true, false])\n  console.log(\n`function slice${dlTag(dl)}(\n  bytes ${dlType(dl)} encoded,\n  uint offset,\n  uint length\n) internal pure returns (bytes ${dlType(dl)} ret, uint nextOffset) {\n  (ret, nextOffset) = slice${dlTag(dl)}Unchecked(encoded, offset, length);\n  checkBound(nextOffset, encoded.length);\n}\n`);\n\nfor (const [name, code, ret] of funcs) {\n  for (const dl of [true, false])\n    console.log(\n`function ${name}${dlTag(dl)}Unchecked(\n  bytes ${dlType(dl)} encoded,\n  uint offset\n) internal pure returns (${ret(dl)} ret, uint nextOffset) {\n  ${code(dl).join(\"\\n  \")}\n}\n\nfunction ${name}${dlTag(dl)}(\n  bytes ${dlType(dl)} encoded,\n  uint offset\n) internal pure returns (${ret(dl)} ret, uint nextOffset) {\n  (ret, nextOffset) = ${name}${dlTag(dl)}Unchecked(encoded, offset);\n  checkBound(nextOffset, encoded.length);\n}\n`);\n}\n------------------------------------------------------------------------------------------------- */\n\n  function sliceCd(\n    bytes calldata encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceCdUnchecked(encoded, offset, length);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceMem(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceMemUnchecked(encoded, offset, length);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint8PrefixedCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    uint8 len;\n    (len, nextOffset) = asUint8CdUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceCdUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint8PrefixedCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint8PrefixedCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint8PrefixedMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    uint8 len;\n    (len, nextOffset) = asUint8MemUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceMemUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint8PrefixedMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint8PrefixedMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint16PrefixedCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    uint16 len;\n    (len, nextOffset) = asUint16CdUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceCdUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint16PrefixedCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint16PrefixedCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint16PrefixedMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    uint16 len;\n    (len, nextOffset) = asUint16MemUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceMemUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint16PrefixedMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint16PrefixedMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint32PrefixedCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    uint32 len;\n    (len, nextOffset) = asUint32CdUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceCdUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint32PrefixedCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes calldata ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint32PrefixedCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function sliceUint32PrefixedMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    uint32 len;\n    (len, nextOffset) = asUint32MemUnchecked(encoded, offset);\n    (ret, nextOffset) = sliceMemUnchecked(encoded, nextOffset, uint(len));\n  }\n\n  function sliceUint32PrefixedMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes memory ret, uint nextOffset) {\n    (ret, nextOffset) = sliceUint32PrefixedMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asAddressCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    uint160 tmp;\n    (tmp, nextOffset) = asUint160CdUnchecked(encoded, offset);\n    ret = address(tmp);\n  }\n\n  function asAddressCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    (ret, nextOffset) = asAddressCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asAddressMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    uint160 tmp;\n    (tmp, nextOffset) = asUint160MemUnchecked(encoded, offset);\n    ret = address(tmp);\n  }\n\n  function asAddressMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (address ret, uint nextOffset) {\n    (ret, nextOffset) = asAddressMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBoolCdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    uint8 val;\n    (val, nextOffset) = asUint8CdUnchecked(encoded, offset);\n    if (val & 0xfe != 0)\n      revert InvalidBoolVal(val);\n    uint cleanedVal = uint(val);\n    //skip 2x iszero opcode\n    /// @solidity memory-safe-assembly\n    assembly { ret := cleanedVal }\n  }\n\n  function asBoolCd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    (ret, nextOffset) = asBoolCdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBoolMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    uint8 val;\n    (val, nextOffset) = asUint8MemUnchecked(encoded, offset);\n    if (val & 0xfe != 0)\n      revert InvalidBoolVal(val);\n    uint cleanedVal = uint(val);\n    //skip 2x iszero opcode\n    /// @solidity memory-safe-assembly\n    assembly { ret := cleanedVal }\n  }\n\n  function asBoolMem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bool ret, uint nextOffset) {\n    (ret, nextOffset) = asBoolMemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint8CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 1)\n      ret := shr(248, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint8Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint8CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint8MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 1)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint8Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint8 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint8MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint16CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 2)\n      ret := shr(240, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint16Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint16CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint16MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 2)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint16Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint16 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint16MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint24CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 3)\n      ret := shr(232, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint24Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint24CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint24MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 3)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint24Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint24 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint24MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint32CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 4)\n      ret := shr(224, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint32Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint32CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint32MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 4)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint32Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint32 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint32MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint40CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 5)\n      ret := shr(216, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint40Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint40CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint40MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 5)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint40Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint40 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint40MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint48CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 6)\n      ret := shr(208, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint48Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint48CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint48MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 6)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint48Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint48 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint48MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint56CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 7)\n      ret := shr(200, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint56Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint56CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint56MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 7)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint56Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint56 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint56MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint64CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 8)\n      ret := shr(192, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint64Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint64CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint64MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 8)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint64Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint64 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint64MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint72CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 9)\n      ret := shr(184, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint72Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint72CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint72MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 9)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint72Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint72 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint72MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint80CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 10)\n      ret := shr(176, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint80Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint80CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint80MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 10)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint80Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint80 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint80MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint88CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 11)\n      ret := shr(168, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint88Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint88CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint88MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 11)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint88Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint88 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint88MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint96CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 12)\n      ret := shr(160, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint96Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint96CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint96MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 12)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint96Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint96 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint96MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint104CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 13)\n      ret := shr(152, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint104Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint104CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint104MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 13)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint104Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint104 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint104MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint112CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 14)\n      ret := shr(144, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint112Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint112CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint112MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 14)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint112Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint112 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint112MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint120CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 15)\n      ret := shr(136, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint120Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint120CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint120MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 15)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint120Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint120 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint120MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint128CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 16)\n      ret := shr(128, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint128Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint128CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint128MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 16)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint128Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint128 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint128MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint136CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 17)\n      ret := shr(120, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint136Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint136CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint136MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 17)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint136Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint136 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint136MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint144CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 18)\n      ret := shr(112, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint144Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint144CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint144MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 18)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint144Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint144 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint144MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint152CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 19)\n      ret := shr(104, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint152Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint152CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint152MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 19)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint152Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint152 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint152MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint160CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 20)\n      ret := shr(96, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint160Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint160CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint160MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 20)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint160Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint160 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint160MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint168CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 21)\n      ret := shr(88, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint168Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint168CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint168MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 21)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint168Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint168 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint168MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint176CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 22)\n      ret := shr(80, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint176Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint176CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint176MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 22)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint176Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint176 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint176MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint184CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 23)\n      ret := shr(72, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint184Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint184CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint184MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 23)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint184Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint184 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint184MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint192CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 24)\n      ret := shr(64, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint192Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint192CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint192MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 24)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint192Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint192 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint192MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint200CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 25)\n      ret := shr(56, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint200Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint200CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint200MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 25)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint200Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint200 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint200MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint208CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 26)\n      ret := shr(48, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint208Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint208CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint208MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 26)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint208Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint208 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint208MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint216CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 27)\n      ret := shr(40, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint216Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint216CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint216MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 27)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint216Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint216 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint216MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint224CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 28)\n      ret := shr(32, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint224Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint224CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint224MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 28)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint224Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint224 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint224MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint232CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 29)\n      ret := shr(24, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint232Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint232CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint232MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 29)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint232Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint232 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint232MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint240CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 30)\n      ret := shr(16, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint240Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint240CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint240MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 30)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint240Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint240 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint240MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint248CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 31)\n      ret := shr(8, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint248Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint248CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint248MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 31)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint248Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint248 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint248MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint256CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 32)\n      ret := shr(0, calldataload(add(encoded.offset, offset)))\n    }\n  }\n\n  function asUint256Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint256CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asUint256MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      nextOffset := add(offset, 32)\n      ret := mload(add(encoded, nextOffset))\n    }\n  }\n\n  function asUint256Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint256 ret, uint nextOffset) {\n    (ret, nextOffset) = asUint256MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes1CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 1)\n    }\n  }\n\n  function asBytes1Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes1CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes1MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 1)\n    }\n  }\n\n  function asBytes1Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes1 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes1MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes2CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 2)\n    }\n  }\n\n  function asBytes2Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes2CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes2MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 2)\n    }\n  }\n\n  function asBytes2Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes2 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes2MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes3CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 3)\n    }\n  }\n\n  function asBytes3Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes3CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes3MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 3)\n    }\n  }\n\n  function asBytes3Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes3 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes3MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes4CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 4)\n    }\n  }\n\n  function asBytes4Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes4CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes4MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 4)\n    }\n  }\n\n  function asBytes4Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes4 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes4MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes5CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 5)\n    }\n  }\n\n  function asBytes5Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes5CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes5MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 5)\n    }\n  }\n\n  function asBytes5Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes5 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes5MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes6CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 6)\n    }\n  }\n\n  function asBytes6Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes6CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes6MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 6)\n    }\n  }\n\n  function asBytes6Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes6 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes6MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes7CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 7)\n    }\n  }\n\n  function asBytes7Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes7CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes7MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 7)\n    }\n  }\n\n  function asBytes7Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes7 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes7MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes8CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 8)\n    }\n  }\n\n  function asBytes8Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes8CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes8MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 8)\n    }\n  }\n\n  function asBytes8Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes8 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes8MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes9CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 9)\n    }\n  }\n\n  function asBytes9Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes9CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes9MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 9)\n    }\n  }\n\n  function asBytes9Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes9 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes9MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes10CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 10)\n    }\n  }\n\n  function asBytes10Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes10CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes10MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 10)\n    }\n  }\n\n  function asBytes10Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes10 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes10MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes11CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 11)\n    }\n  }\n\n  function asBytes11Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes11CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes11MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 11)\n    }\n  }\n\n  function asBytes11Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes11 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes11MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes12CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 12)\n    }\n  }\n\n  function asBytes12Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes12CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes12MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 12)\n    }\n  }\n\n  function asBytes12Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes12 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes12MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes13CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 13)\n    }\n  }\n\n  function asBytes13Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes13CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes13MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 13)\n    }\n  }\n\n  function asBytes13Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes13 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes13MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes14CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 14)\n    }\n  }\n\n  function asBytes14Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes14CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes14MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 14)\n    }\n  }\n\n  function asBytes14Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes14 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes14MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes15CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 15)\n    }\n  }\n\n  function asBytes15Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes15CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes15MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 15)\n    }\n  }\n\n  function asBytes15Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes15 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes15MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes16CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 16)\n    }\n  }\n\n  function asBytes16Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes16CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes16MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 16)\n    }\n  }\n\n  function asBytes16Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes16 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes16MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes17CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 17)\n    }\n  }\n\n  function asBytes17Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes17CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes17MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 17)\n    }\n  }\n\n  function asBytes17Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes17 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes17MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes18CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 18)\n    }\n  }\n\n  function asBytes18Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes18CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes18MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 18)\n    }\n  }\n\n  function asBytes18Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes18 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes18MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes19CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 19)\n    }\n  }\n\n  function asBytes19Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes19CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes19MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 19)\n    }\n  }\n\n  function asBytes19Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes19 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes19MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes20CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 20)\n    }\n  }\n\n  function asBytes20Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes20CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes20MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 20)\n    }\n  }\n\n  function asBytes20Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes20 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes20MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes21CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 21)\n    }\n  }\n\n  function asBytes21Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes21CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes21MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 21)\n    }\n  }\n\n  function asBytes21Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes21 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes21MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes22CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 22)\n    }\n  }\n\n  function asBytes22Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes22CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes22MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 22)\n    }\n  }\n\n  function asBytes22Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes22 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes22MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes23CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 23)\n    }\n  }\n\n  function asBytes23Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes23CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes23MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 23)\n    }\n  }\n\n  function asBytes23Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes23 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes23MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes24CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 24)\n    }\n  }\n\n  function asBytes24Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes24CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes24MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 24)\n    }\n  }\n\n  function asBytes24Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes24 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes24MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes25CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 25)\n    }\n  }\n\n  function asBytes25Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes25CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes25MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 25)\n    }\n  }\n\n  function asBytes25Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes25 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes25MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes26CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 26)\n    }\n  }\n\n  function asBytes26Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes26CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes26MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 26)\n    }\n  }\n\n  function asBytes26Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes26 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes26MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes27CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 27)\n    }\n  }\n\n  function asBytes27Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes27CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes27MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 27)\n    }\n  }\n\n  function asBytes27Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes27 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes27MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes28CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 28)\n    }\n  }\n\n  function asBytes28Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes28CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes28MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 28)\n    }\n  }\n\n  function asBytes28Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes28 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes28MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes29CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 29)\n    }\n  }\n\n  function asBytes29Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes29CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes29MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 29)\n    }\n  }\n\n  function asBytes29Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes29 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes29MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes30CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 30)\n    }\n  }\n\n  function asBytes30Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes30CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes30MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 30)\n    }\n  }\n\n  function asBytes30Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes30 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes30MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes31CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 31)\n    }\n  }\n\n  function asBytes31Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes31CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes31MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 31)\n    }\n  }\n\n  function asBytes31Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes31 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes31MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes32CdUnchecked(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := calldataload(add(encoded.offset, offset))\n      nextOffset := add(offset, 32)\n    }\n  }\n\n  function asBytes32Cd(\n    bytes calldata encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes32CdUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n\n  function asBytes32MemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      ret := mload(add(encoded, add(offset, WORD_SIZE)))\n      nextOffset := add(offset, 32)\n    }\n  }\n\n  function asBytes32Mem(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (bytes32 ret, uint nextOffset) {\n    (ret, nextOffset) = asBytes32MemUnchecked(encoded, offset);\n    checkBound(nextOffset, encoded.length);\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/interfaces/ITokenBridge.sol": {
      "content": "// contracts/Bridge.sol\n// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"./IWormhole.sol\";\n\ninterface ITokenBridge {\n  struct Transfer {\n    uint8 payloadID;\n    uint256 amount;\n    bytes32 tokenAddress;\n    uint16 tokenChain;\n    bytes32 to;\n    uint16 toChain;\n    uint256 fee;\n  }\n\n  struct TransferWithPayload {\n    uint8 payloadID;\n    uint256 amount;\n    bytes32 tokenAddress;\n    uint16 tokenChain;\n    bytes32 to;\n    uint16 toChain;\n    bytes32 fromAddress;\n    bytes payload;\n  }\n\n  struct AssetMeta {\n    uint8 payloadID;\n    bytes32 tokenAddress;\n    uint16 tokenChain;\n    uint8 decimals;\n    bytes32 symbol;\n    bytes32 name;\n  }\n\n  struct RegisterChain {\n    bytes32 module;\n    uint8 action;\n    uint16 chainId;\n    uint16 emitterChainID;\n    bytes32 emitterAddress;\n  }\n\n  struct UpgradeContract {\n    bytes32 module;\n    uint8 action;\n    uint16 chainId;\n    bytes32 newContract;\n  }\n\n  struct RecoverChainId {\n    bytes32 module;\n    uint8 action;\n    uint256 evmChainId;\n    uint16 newChainId;\n  }\n\n  event ContractUpgraded(address indexed oldContract, address indexed newContract);\n\n  event TransferRedeemed(\n    uint16 indexed emitterChainId,\n    bytes32 indexed emitterAddress,\n    uint64 indexed sequence\n  );\n\n  function _parseTransferCommon(\n    bytes memory encoded\n  ) external pure returns (Transfer memory transfer);\n\n  function attestToken(\n    address tokenAddress,\n    uint32 nonce\n  ) external payable returns (uint64 sequence);\n\n  function wrapAndTransferETH(\n    uint16 recipientChain,\n    bytes32 recipient,\n    uint256 arbiterFee,\n    uint32 nonce\n  ) external payable returns (uint64 sequence);\n\n  function wrapAndTransferETHWithPayload(\n    uint16 recipientChain,\n    bytes32 recipient,\n    uint32 nonce,\n    bytes memory payload\n  ) external payable returns (uint64 sequence);\n\n  function transferTokens(\n    address token,\n    uint256 amount,\n    uint16 recipientChain,\n    bytes32 recipient,\n    uint256 arbiterFee,\n    uint32 nonce\n  ) external payable returns (uint64 sequence);\n\n  function transferTokensWithPayload(\n    address token,\n    uint256 amount,\n    uint16 recipientChain,\n    bytes32 recipient,\n    uint32 nonce,\n    bytes memory payload\n  ) external payable returns (uint64 sequence);\n\n  function updateWrapped(bytes memory encodedVm) external returns (address token);\n\n  function createWrapped(bytes memory encodedVm) external returns (address token);\n\n  function completeTransferWithPayload(bytes memory encodedVm) external returns (bytes memory);\n\n  function completeTransferAndUnwrapETHWithPayload(\n    bytes memory encodedVm\n  ) external returns (bytes memory);\n\n  function completeTransfer(bytes memory encodedVm) external;\n\n  function completeTransferAndUnwrapETH(bytes memory encodedVm) external;\n\n  function encodeAssetMeta(AssetMeta memory meta) external pure returns (bytes memory encoded);\n\n  function encodeTransfer(Transfer memory transfer) external pure returns (bytes memory encoded);\n\n  function encodeTransferWithPayload(TransferWithPayload memory transfer)\n    external\n    pure\n    returns (bytes memory encoded);\n\n  function parsePayloadID(bytes memory encoded) external pure returns (uint8 payloadID);\n\n  function parseAssetMeta(bytes memory encoded) external pure returns (AssetMeta memory meta);\n\n  function parseTransfer(bytes memory encoded) external pure returns (Transfer memory transfer);\n\n  function parseTransferWithPayload(bytes memory encoded)\n    external\n    pure\n    returns (TransferWithPayload memory transfer);\n\n  function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\n\n  function isInitialized(address impl) external view returns (bool);\n\n  function isTransferCompleted(bytes32 hash) external view returns (bool);\n\n  function wormhole() external view returns (IWormhole);\n\n  function chainId() external view returns (uint16);\n\n  function evmChainId() external view returns (uint256);\n\n  function isFork() external view returns (bool);\n\n  function governanceChainId() external view returns (uint16);\n\n  function governanceContract() external view returns (bytes32);\n\n  function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) external view returns (address);\n\n  function bridgeContracts(uint16 chainId_) external view returns (bytes32);\n\n  function tokenImplementation() external view returns (address);\n\n  function WETH() external view returns (address);\n\n  function outstandingBridged(address token) external view returns (uint256);\n\n  function isWrappedAsset(address token) external view returns (bool);\n\n  function finality() external view returns (uint8);\n\n  function implementation() external view returns (address);\n\n  function initialize() external;\n\n  function registerChain(bytes memory encodedVM) external;\n\n  function upgrade(bytes memory encodedVM) external;\n\n  function submitRecoverChainId(bytes memory encodedVM) external;\n\n  function parseRegisterChain(\n    bytes memory encoded\n  ) external pure returns (RegisterChain memory chain);\n\n  function parseUpgrade(\n    bytes memory encoded\n  ) external pure returns (UpgradeContract memory chain);\n\n  function parseRecoverChainId(\n    bytes memory encodedRecoverChainId\n  ) external pure returns (RecoverChainId memory rci);\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/interfaces/token/IWETH.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"IERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n  event Deposit(address indexed dst, uint amount);\n  event Withdrawal(address indexed src, uint amount);\n\n  function deposit() external payable;\n  function withdraw(uint256 amount) external;\n}\n"
    },
    "lib/permit2/src/interfaces/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"
    },
    "src/assets/TbrDispatcher.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\nimport { BytesParsing } from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport { SweepTokens } from \"wormhole-sdk/components/dispatcher/SweepTokens.sol\";\nimport { tokenOrNativeTransfer } from \"wormhole-sdk/utils/Transfer.sol\";\nimport { RawDispatcher } from \"wormhole-sdk/RawDispatcher.sol\";\nimport { Upgrade } from \"wormhole-sdk/components/dispatcher/Upgrade.sol\";\nimport { InvalidCommand } from \"./TbrBase.sol\";\nimport { TbrConfig } from \"./TbrConfig.sol\";\nimport { TbrUser } from \"./TbrUser.sol\";\nimport \"wormhole-sdk/components/dispatcher/Ids.sol\";\nimport \"./TbrIds.sol\";\n\n/**\n * Command protocol version is unsupported\n */\nerror UnsupportedVersion(uint8 version);\n\nabstract contract TbrDispatcher is RawDispatcher, TbrConfig, TbrUser, SweepTokens, Upgrade {\n  using BytesParsing for bytes;\n\n  function _exec(bytes calldata data) internal override returns (bytes memory) { unchecked {\n    //nothing here can overflow or underflow - in particular, underflows are checked in the\n    //  associated transfer functions\n    uint offset = 0;\n    uint8 version;\n    (version, offset) = data.asUint8CdUnchecked(offset);\n\n    if (version != DISPATCHER_PROTOCOL_VERSION0)\n      revert UnsupportedVersion(version);\n\n    uint256 senderRefund = msg.value;\n    uint256 fees = 0;\n    uint256 commandIndex = 0;\n    while (offset < data.length) {\n      uint8 command;\n      (command, offset) = data.asUint8CdUnchecked(offset);\n\n      if (command == TRANSFER_TOKEN_WITH_RELAY_ID) {\n        uint256 fee; uint256 gasTokenSent;\n        (fee, gasTokenSent, offset) =\n          _transferTokenWithRelay(data, offset, senderRefund, commandIndex);\n        fees += fee;\n        senderRefund -= fee + gasTokenSent;\n      } else if (command == TRANSFER_GAS_TOKEN_WITH_RELAY_ID) {\n        uint256 fee; uint256 gasTokenSent;\n        (fee, gasTokenSent, offset) =\n          _transferGasTokenWithRelay(data, offset, senderRefund, commandIndex);\n        fees += fee;\n        senderRefund -= fee + gasTokenSent;\n      } else if (command == COMPLETE_TRANSFER_ID) {\n        uint256 gasDropoffSpent;\n        (gasDropoffSpent, offset) = _completeTransfer(data, offset, senderRefund, commandIndex);\n        senderRefund -= gasDropoffSpent;\n      } else if (command == APPROVE_TOKEN_ID)\n        offset = _approveToken(data, offset);\n      else if (command == CONFIG_ID)\n        offset = _batchConfigCommands(data, offset);\n      else {\n        bool dispatched;\n          (dispatched, offset) = dispatchExecAccessControl(data, offset, command);\n        if (!dispatched)\n          (dispatched, offset) = dispatchExecUpgrade(data, offset, command);\n        if (!dispatched)\n          (dispatched, offset) = dispatchExecSweepTokens(data, offset, command);\n        if (!dispatched)\n          revert InvalidCommand(command, commandIndex);\n      }\n\n      ++commandIndex;\n    }\n\n    BytesParsing.checkLength(offset, data.length);\n\n    tokenOrNativeTransfer(address(0), _getFeeRecipient(), fees);\n    tokenOrNativeTransfer(address(0), msg.sender, senderRefund);\n    return new bytes(0);\n  }}\n\n  function _get(bytes calldata data) internal view override returns (bytes memory) { unchecked {\n    bytes memory ret;\n    uint offset = 0;\n    uint8 version;\n    (version, offset) = data.asUint8CdUnchecked(offset);\n\n    if (version != DISPATCHER_PROTOCOL_VERSION0)\n      revert UnsupportedVersion(version);\n\n    uint queryIndex = 0;\n    while (offset < data.length) {\n      uint8 query;\n      (query, offset) = data.asUint8CdUnchecked(offset);\n\n      bytes memory result;\n      if (query == RELAY_FEE_ID)\n        (result, offset) = _relayFee(data, offset, queryIndex);\n      else if (query == BASE_RELAYING_CONFIG_ID)\n        (result, offset) = _baseRelayingConfig(data, offset, queryIndex);\n      else if (query == CONFIG_QUERIES_ID)\n        (result, offset) = _batchConfigQueries(data, offset);\n      else if (query == ALLOWANCE_TOKEN_BRIDGE_ID)\n        (result, offset) = _allowanceTokenBridge(data, offset);\n      else if (query == GAS_TOKEN_ID)\n        result = abi.encodePacked(gasToken);\n      else if (query == GAS_TOKEN_ALLOWANCE_TOKEN_BRIDGE_ID)\n        result = abi.encodePacked(_allowanceTokenBridgeImpl(address(gasToken)));\n      else {\n        bool dispatched;\n        (dispatched, result, offset) = dispatchQueryAccessControl(data, offset, query);\n        if (!dispatched)\n          (dispatched, result, offset) = dispatchQueryUpgrade(data, offset, query);\n        if (!dispatched)\n          revert InvalidCommand(query, queryIndex);\n      }\n\n      ret = abi.encodePacked(ret, result);\n      ++queryIndex;\n    }\n    BytesParsing.checkLength(offset, data.length);\n    return ret;\n  }}\n}"
    },
    "src/assets/TbrBase.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\nimport {IWETH} from \"wormhole-sdk/interfaces/token/IWETH.sol\";\nimport {IWormhole} from \"wormhole-sdk/interfaces/IWormhole.sol\";\nimport {ITokenBridge} from \"wormhole-sdk/interfaces/ITokenBridge.sol\";\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {IPermit2} from \"permit2/IPermit2.sol\";\nimport {PriceOracleIntegration} from \"price-oracle/PriceOracleIntegration.sol\";\n\n/**\n * Decoding the command failed.\n */\nerror InvalidCommand(uint8 command, uint256 commandIndex);\n\nstruct ChainData {\n  /**\n   * @notice The canonical peer for the chain, i.e. to whom the relayer will send the messages to\n   */\n  bytes32 canonicalPeer;\n  /**\n   * @notice The peers allowed on the target chain, i.e. the relayer will receive the messages from those peers\n   */\n  mapping(bytes32 => bool) peers;\n  /**\n   * @notice The base fee is denominated in µusd.\n   */\n  uint32 baseFee;\n  /**\n   * @notice The maximum gas dropoff is denominated in µ gas token of the target chain native token\n   */\n  uint32 maxGasDropoff;\n  /**\n   * @notice If the chain is paused, no outbound transfers will be allowed\n   */\n  bool paused;\n}\n\nstruct TbrChainState {\n  /**\n   * @notice The state related to each target chain\n   */\n  mapping(uint16 => ChainData) data;\n}\n\n// keccak256(\"TbrChainState\") - 1\nbytes32 constant TBR_CHAIN_STORAGE_SLOT =\n  0x076d7575784c7c4eaae6dbc87cd7dc63264c591f7395b7447b536cfc549b21c5;\n\nfunction tbrChainState(uint16 targetChain) view returns (ChainData storage) {\n  TbrChainState storage state;\n  assembly (\"memory-safe\") {\n    state.slot := TBR_CHAIN_STORAGE_SLOT\n  }\n  return state.data[targetChain];\n}\n\n/**\n * The peer provided is invalid.\n */\nerror PeerIsZeroAddress();\n/**\n * Chain id 0 is invalid.\n */\nerror InvalidChainId();\n/**\n * The specified chain is not registered in the Token Bridge contract.\n */\nerror ChainNotSupportedByTokenBridge(uint16 chainId);\n/**\n * This TBR instance doesn't have a peer in the specified chain.\n */\nerror ChainIsNotRegistered(uint16 chainId);\n\n\nabstract contract TbrBase is PriceOracleIntegration {\n  using BytesParsing for bytes;\n\n  // 18 decimal precision representation / _TOTAL_FEE_DIVISOR = uint64 total fee\n  uint internal constant _TOTAL_FEE_DIVISOR = 1e6;\n\n  IPermit2     internal immutable permit2;\n  uint16       internal immutable whChainId;\n  IWormhole    internal immutable wormholeCore;\n  ITokenBridge internal immutable tokenBridge;\n  IWETH        internal immutable gasToken;\n  /**\n   * If true, the contract will call `deposit()` or `withdraw()`\n   * to convert from the native gas token to the ERC20 token and viceversa.\n   */\n  bool         internal immutable gasErc20TokenizationIsExplicit;\n\n  constructor(\n    IPermit2 initPermit2,\n    ITokenBridge initTokenBridge,\n    address oracle,\n    IWETH initGasToken,\n    bool initGasErc20TokenizationIsExplicit\n  ) PriceOracleIntegration(oracle) {\n    wormholeCore = initTokenBridge.wormhole();\n    whChainId = _oracleChainId();\n    permit2 = initPermit2;\n    tokenBridge = initTokenBridge;\n    gasToken = initGasToken;\n    gasErc20TokenizationIsExplicit = initGasErc20TokenizationIsExplicit;\n  }\n\n  function _getTargetChainData(\n    uint16 targetChain\n  ) internal view returns (bytes32, uint32, uint32, bool) {\n    ChainData storage state = tbrChainState(targetChain);\n    return (\n      state.canonicalPeer,\n      state.baseFee,\n      state.maxGasDropoff,\n      state.paused\n    );\n  }\n\n  function _isPeer(uint16 targetChain, bytes32 peer) internal view returns (bool) {\n    return tbrChainState(targetChain).peers[peer];\n  }\n\n  function _addPeer(uint16 targetChain, bytes32 peer) internal {\n    if (targetChain == 0 || targetChain == whChainId)\n      revert InvalidChainId();\n\n    if (peer == bytes32(0))\n      revert PeerIsZeroAddress();\n\n    bytes32 bridgeContractOnPeerChain = tokenBridge.bridgeContracts(targetChain);\n    if (bridgeContractOnPeerChain == bytes32(0))\n      revert ChainNotSupportedByTokenBridge(targetChain);\n\n    ChainData storage state = tbrChainState(targetChain);\n    if (state.canonicalPeer == bytes32(0))\n      state.canonicalPeer = peer;\n\n    state.peers[peer] = true;\n  }\n\n  function _getCanonicalPeer(uint16 targetChain) internal view returns (bytes32) {\n    return tbrChainState(targetChain).canonicalPeer;\n  }\n\n  function _setCanonicalPeer(uint16 targetChain, bytes32 peer) internal {\n    ChainData storage state = tbrChainState(targetChain);\n    bool isAlreadyPeer = state.peers[peer];\n    if (!isAlreadyPeer)\n      _addPeer(targetChain, peer);\n    if (state.canonicalPeer != peer)\n      state.canonicalPeer = peer;\n  }\n\n  function _isChainSupported(uint16 targetChain) internal view returns (bool) {\n    return _getCanonicalPeer(targetChain) != bytes32(0);\n  }\n\n  function _getBaseFee(uint16 targetChain) internal view returns (uint32) {\n    return tbrChainState(targetChain).baseFee;\n  }\n\n  function _setBaseFee(uint16 targetChain, uint32 baseFee) internal {\n    ChainData storage state = tbrChainState(targetChain);\n    if (state.canonicalPeer == bytes32(0)) {\n      revert ChainIsNotRegistered(targetChain);\n    }\n    state.baseFee = baseFee;\n  }\n\n  function _getMaxGasDropoff(uint16 targetChain) internal view returns (uint32) {\n    return tbrChainState(targetChain).maxGasDropoff;\n  }\n\n  function _setMaxGasDropoff(uint16 targetChain, uint32 maxGasDropoff) internal {\n    ChainData storage state = tbrChainState(targetChain);\n    if (state.canonicalPeer == bytes32(0)) {\n      revert ChainIsNotRegistered(targetChain);\n    }\n    state.maxGasDropoff = maxGasDropoff;\n  }\n\n  /**\n   * @notice Check if outbound transfers are paused for a given chain\n   */\n  function _isPaused(uint16 targetChain) internal view returns (bool) {\n    return tbrChainState(targetChain).paused;\n  }\n\n  /**\n   * @notice Set outbound transfers for a given chain\n   */\n  function _setPause(uint16 targetChain, bool paused) internal {\n    ChainData storage state = tbrChainState(targetChain);\n    if (state.canonicalPeer == bytes32(0)) {\n      revert ChainIsNotRegistered(targetChain);\n    }\n    state.paused = paused;\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/constants/Common.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.4;\n\n// ┌──────────────────────────────────────────────────────────────────────────────┐\n// │ NOTE: We can't define e.g. WORD_SIZE_MINUS_ONE via WORD_SIZE - 1 because     │\n// │       of solc restrictions on what constants can be used in inline assembly. │\n// └──────────────────────────────────────────────────────────────────────────────┘\n\nuint256 constant WORD_SIZE = 32;\nuint256 constant WORD_SIZE_MINUS_ONE = 31; //=0x1f=0b00011111\n//see section \"prefer `< MAX + 1` over `<= MAX` for const comparison\" in docs/Optimization.md\nuint256 constant WORD_SIZE_PLUS_ONE = 33;\n\nuint256 constant SCRATCH_SPACE_PTR = 0x00;\nuint256 constant SCRATCH_SPACE_SIZE = 64;\n\nuint256 constant FREE_MEMORY_PTR = 0x40;"
    },
    "lib/wormhole-solidity-sdk/src/interfaces/IWormhole.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\ninterface IWormhole {\n  struct GuardianSet {\n    address[] keys;\n    uint32 expirationTime;\n  }\n\n  struct Signature {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    uint8 guardianIndex;\n  }\n\n  struct VM {\n    uint8 version;\n    uint32 timestamp;\n    uint32 nonce;\n    uint16 emitterChainId;\n    bytes32 emitterAddress;\n    uint64 sequence;\n    uint8 consistencyLevel;\n    bytes payload;\n    uint32 guardianSetIndex;\n    Signature[] signatures;\n    bytes32 hash;\n  }\n\n  struct ContractUpgrade {\n    bytes32 module;\n    uint8 action;\n    uint16 chain;\n    address newContract;\n  }\n\n  struct GuardianSetUpgrade {\n    bytes32 module;\n    uint8 action;\n    uint16 chain;\n    GuardianSet newGuardianSet;\n    uint32 newGuardianSetIndex;\n  }\n\n  struct SetMessageFee {\n    bytes32 module;\n    uint8 action;\n    uint16 chain;\n    uint256 messageFee;\n  }\n\n  struct TransferFees {\n    bytes32 module;\n    uint8 action;\n    uint16 chain;\n    uint256 amount;\n    bytes32 recipient;\n  }\n\n  struct RecoverChainId {\n    bytes32 module;\n    uint8 action;\n    uint256 evmChainId;\n    uint16 newChainId;\n  }\n\n  event LogMessagePublished(\n    address indexed sender,\n    uint64 sequence,\n    uint32 nonce,\n    bytes payload,\n    uint8 consistencyLevel\n  );\n\n  event ContractUpgraded(address indexed oldContract, address indexed newContract);\n\n  event GuardianSetAdded(uint32 indexed index);\n\n  function publishMessage(uint32 nonce, bytes memory payload, uint8 consistencyLevel)\n    external\n    payable\n    returns (uint64 sequence);\n\n  function initialize() external;\n\n  function parseAndVerifyVM(bytes calldata encodedVM)\n    external\n    view\n    returns (VM memory vm, bool valid, string memory reason);\n\n  function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\n\n  function verifySignatures(\n    bytes32 hash,\n    Signature[] memory signatures,\n    GuardianSet memory guardianSet\n  ) external pure returns (bool valid, string memory reason);\n\n  function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\n\n  function quorum(\n    uint256 numGuardians\n  ) external pure returns (uint256 numSignaturesRequiredForQuorum);\n\n  function getGuardianSet(uint32 index) external view returns (GuardianSet memory);\n\n  function getCurrentGuardianSetIndex() external view returns (uint32);\n\n  function getGuardianSetExpiry() external view returns (uint32);\n\n  function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\n\n  function isInitialized(address impl) external view returns (bool);\n\n  function chainId() external view returns (uint16);\n\n  function isFork() external view returns (bool);\n\n  function governanceChainId() external view returns (uint16);\n\n  function governanceContract() external view returns (bytes32);\n\n  function messageFee() external view returns (uint256);\n\n  function evmChainId() external view returns (uint256);\n\n  function nextSequence(address emitter) external view returns (uint64);\n\n  function parseContractUpgrade(\n    bytes memory encodedUpgrade\n  ) external pure returns (ContractUpgrade memory cu);\n\n  function parseGuardianSetUpgrade(\n    bytes memory encodedUpgrade\n  ) external pure returns (GuardianSetUpgrade memory gsu);\n\n  function parseSetMessageFee(\n    bytes memory encodedSetMessageFee\n  ) external pure returns (SetMessageFee memory smf);\n\n  function parseTransferFees(\n    bytes memory encodedTransferFees\n  ) external pure returns (TransferFees memory tf);\n\n  function parseRecoverChainId(\n    bytes memory encodedRecoverChainId\n  ) external pure returns (RecoverChainId memory rci);\n\n  function submitContractUpgrade(bytes memory _vm) external;\n\n  function submitSetMessageFee(bytes memory _vm) external;\n\n  function submitNewGuardianSet(bytes memory _vm) external;\n\n  function submitTransferFees(bytes memory _vm) external;\n\n  function submitRecoverChainId(bytes memory _vm) external;\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/interfaces/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\n//https://eips.ethereum.org/EIPS/eip-20\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/permit2/src/interfaces/ISignatureTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"
    },
    "lib/permit2/src/interfaces/IAllowanceTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/components/dispatcher/SweepTokens.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.4;\n\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {tokenOrNativeTransfer} from \"wormhole-sdk/Utils.sol\";\nimport {senderAtLeastAdmin} from \"wormhole-sdk/components/dispatcher/AccessControl.sol\";\nimport {SWEEP_TOKENS_ID} from \"wormhole-sdk/components/dispatcher/Ids.sol\";\n\nabstract contract SweepTokens {\n  using BytesParsing for bytes;\n\n  function dispatchExecSweepTokens(\n    bytes calldata data,\n    uint offset,\n    uint8 command\n  ) internal returns (bool, uint) {\n    return command == SWEEP_TOKENS_ID\n      ? (true, _sweepTokens(data, offset))\n      : (false, offset);\n  }\n\n  function _sweepTokens(\n    bytes calldata commands,\n    uint offset\n  ) internal returns (uint) {\n    sweepTokenDoAuth();\n\n    address token;\n    uint256 amount;\n    (token,  offset) = commands.asAddressCdUnchecked(offset);\n    (amount, offset) = commands.asUint256CdUnchecked(offset);\n\n    tokenOrNativeTransfer(token, msg.sender, amount);\n    return offset;\n  }\n\n  function sweepTokenDoAuth() view internal virtual {\n    senderAtLeastAdmin();\n  }\n}"
    },
    "lib/wormhole-solidity-sdk/src/utils/Transfer.sol": {
      "content": "\n// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"IERC20/IERC20.sol\";\nimport {SafeERC20} from \"SafeERC20/SafeERC20.sol\";\n\nerror PaymentFailure(address target);\n\n//Note: Always forwards all gas, so consider gas griefing attack opportunities by the recipient.\n//Note: Don't use this method if you need events for 0 amount transfers.\nfunction tokenOrNativeTransfer(address tokenOrZeroForNative, address to, uint256 amount) {\n  if (amount == 0)\n    return;\n\n  if (tokenOrZeroForNative == address(0)) {\n    (bool success, ) = to.call{value: amount}(new bytes(0));\n    if (!success)\n      revert PaymentFailure(to);\n  }\n  else\n    SafeERC20.safeTransfer(IERC20(tokenOrZeroForNative), to, amount);\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/RawDispatcher.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\n//TL;DR:\n//  Allows implementing custom call dispatching logic that is more efficient both in terms\n//    of gas (only when using the via-IR pipeline!) and calldata size than Solidity's default\n//    encoding and dispatching.\n//\n//  The numbers in the function names of this contract are meaningless and only serve the\n//    purpose of yielding a low selector that will guarantee that these functions will come\n//    first in Solidity's default function sorting _when using the via-IR pipeline_.\n//\n//See docs/RawDispatcher.md for details.\nabstract contract RawDispatcher {\n\n  //selector: 00000eb6\n  function exec768() external payable returns (bytes memory) {\n    return _exec(msg.data[4:]);\n  }\n\n  //selector: 0008a112\n  function get1959() external view returns (bytes memory) {\n    return _get(msg.data[4:]);\n  }\n\n  function _exec(bytes calldata data) internal virtual returns (bytes memory);\n\n  function _get(bytes calldata data) internal view virtual returns (bytes memory);\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/components/dispatcher/Upgrade.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.4;\n\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {ProxyBase} from \"wormhole-sdk/proxy/ProxyBase.sol\";\nimport {Role, senderRole, failAuthIf} from \"wormhole-sdk/components/dispatcher/AccessControl.sol\";\nimport {UPGRADE_CONTRACT_ID, IMPLEMENTATION_ID} from \"wormhole-sdk/components/dispatcher/Ids.sol\";\n\nerror InvalidGovernanceCommand(uint8 command);\nerror InvalidGovernanceQuery(uint8 query);\n\nabstract contract Upgrade is ProxyBase {\n  using BytesParsing for bytes;\n\n  // ------ external ------\n\n  //selector: c987336c\n  function upgrade(address implementation, bytes calldata data) external {\n    failAuthIf(senderRole() != Role.Owner);\n\n    _upgradeTo(implementation, data);\n  }\n\n  // ------ internal ------\n\n  /**\n   * Dispatch an execute function. Execute functions almost always modify contract state.\n   */\n  function dispatchExecUpgrade(\n    bytes calldata data,\n    uint offset,\n    uint8 command\n  ) internal returns (bool, uint) {\n    return (command == UPGRADE_CONTRACT_ID)\n      ? (true, _upgradeContract(data, offset))\n      : (false, offset);\n  }\n\n  /**\n   * Dispatch a query function. Query functions never modify contract state.\n   */\n  function dispatchQueryUpgrade(\n    bytes calldata,\n    uint offset,\n    uint8 query\n  ) view internal returns (bool, bytes memory, uint) {\n    return query == IMPLEMENTATION_ID\n      ? (true, abi.encodePacked(_getImplementation()), offset)\n      : (false, new bytes(0), offset);\n  }\n\n  function _upgradeContract(\n    bytes calldata commands,\n    uint offset\n  ) internal returns (uint) {\n    failAuthIf(senderRole() != Role.Owner);\n\n    address newImplementation;\n    (newImplementation, offset) = commands.asAddressCdUnchecked(offset);\n    bytes calldata data;\n    (data, offset) = commands.sliceCdUnchecked(offset, commands.length - offset);\n\n    //contract upgrades must be the last command in the batch\n    BytesParsing.checkLength(offset, commands.length);\n\n    _upgradeTo(newImplementation, data);\n\n    return offset;\n  }\n}\n"
    },
    "src/assets/TbrConfig.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\nimport {\n  AccessControl,\n  Role,\n  NotAuthorized,\n  senderAtLeastAdmin\n} from \"wormhole-sdk/components/dispatcher/AccessControl.sol\";\nimport { BytesParsing } from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport { TbrBase } from \"./TbrBase.sol\";\nimport \"./TbrIds.sol\";\n\nstruct ConfigState {\n  address payable feeRecipient;\n}\n\n// keccak256(\"ConfigState\") - 1\nbytes32 constant CONFIG_STORAGE_SLOT =\n  0xa1f28b22c196686da956abee6956ab0f6625f5b97ed2295735931c66c7c7b5e8;\n\nfunction configState() pure returns (ConfigState storage state) {\n  assembly (\"memory-safe\") { state.slot := CONFIG_STORAGE_SLOT }\n}\n\nerror InvalidFeeRecipient();\nerror InvalidConfigCommand(uint8 command);\nerror InvalidConfigQuery(uint8 query);\n\nevent FeeRecipienUpdated(address oldAddress, address newAddress, uint256 timestamp);\n\nabstract contract TbrConfig is TbrBase, AccessControl {\n  using BytesParsing for bytes;\n\n  // ---- construction ----\n\n  function _configConstruction(\n    address payable feeRecipient\n  ) internal {\n    if (feeRecipient == address(0))\n      revert InvalidFeeRecipient();\n\n    configState().feeRecipient  = feeRecipient;\n  }\n\n  // ---- externals ----\n\n  function _batchConfigCommands(bytes calldata commands, uint offset) internal returns (uint) {\n    bool isOwner = senderAtLeastAdmin() == Role.Owner;\n\n    uint commandCount;\n    (commandCount, offset) = commands.asUint8CdUnchecked(offset);\n\n    for (uint i = 0; i < commandCount; ++i) {\n      uint8 command;\n      (command, offset) = commands.asUint8CdUnchecked(offset);\n\n      if (command == ADD_PEER_ID) {\n        uint16 peerChain;\n        bytes32 newPeer;\n        (peerChain, offset) = commands.asUint16CdUnchecked(offset);\n        (newPeer,   offset) = commands.asBytes32CdUnchecked(offset);\n        _addPeer(peerChain, newPeer);\n      }\n      else if (command == UPDATE_BASE_FEE_ID) {\n        uint16 targetChain;\n        uint32 newBaseFee;\n        (targetChain, offset) = commands.asUint16CdUnchecked(offset);\n        (newBaseFee,  offset) = commands.asUint32CdUnchecked(offset);\n        _setBaseFee(targetChain, newBaseFee);\n      }\n      else if (command == UPDATE_MAX_GAS_DROPOFF_ID) {\n        uint16 targetChain;\n        uint32 newMaxGasDropoff;\n        (targetChain,      offset) = commands.asUint16CdUnchecked(offset);\n        (newMaxGasDropoff, offset) = commands.asUint32CdUnchecked(offset);\n        _setMaxGasDropoff(targetChain, newMaxGasDropoff);\n      }\n      else if (command == PAUSE_CHAIN_ID) {\n        uint16 targetChain;\n        bool paused;\n        (targetChain, offset) = commands.asUint16CdUnchecked(offset);\n        (paused,      offset) = commands.asBoolCdUnchecked(offset);\n        _setPause(targetChain, paused);\n      }\n      else if (command == UPDATE_FEE_RECIPIENT_ID) {\n        address newFeeRecipient;\n        (newFeeRecipient, offset) = commands.asAddressCdUnchecked(offset);\n        _setFeeRecipient(newFeeRecipient);\n      }\n      else if (command == UPDATE_CANONICAL_PEER_ID) {\n        if (!isOwner)\n          revert NotAuthorized();\n        uint16 peerChain;\n        bytes32 newCanonicalPeer;\n        (peerChain,        offset) = commands.asUint16CdUnchecked(offset);\n        (newCanonicalPeer, offset) = commands.asBytes32CdUnchecked(offset);\n        _setCanonicalPeer(peerChain, newCanonicalPeer);\n      }\n      else\n        revert InvalidConfigCommand(command);\n\n    }\n    return offset;\n  }\n\n  function _batchConfigQueries(\n    bytes calldata queries,\n    uint offset\n  ) internal view returns (bytes memory, uint) {\n    bytes memory ret;\n    uint8 queryCount;\n    (queryCount, offset) = queries.asUint8CdUnchecked(offset);\n\n    for (uint8 i = 0; i < queryCount; ++i) {\n      uint8 query;\n      (query, offset) = queries.asUint8CdUnchecked(offset);\n\n      if (query == BASE_FEE_ID) {\n        uint16 targetChainId;\n        (targetChainId, offset) = queries.asUint16CdUnchecked(offset);\n        ret = abi.encodePacked(ret, _getBaseFee(targetChainId));\n      }\n      else if (query == MAX_GAS_DROPOFF_ID) {\n        uint16 targetChainId;\n        (targetChainId, offset) = queries.asUint16CdUnchecked(offset);\n        ret = abi.encodePacked(ret, _getMaxGasDropoff(targetChainId));\n      }\n      else if (query == IS_CHAIN_PAUSED_ID) {\n        uint16 chainId;\n        (chainId, offset) = queries.asUint16CdUnchecked(offset);\n        ret = abi.encodePacked(ret, _isPaused(chainId));\n      }\n      else if (query == IS_PEER_ID) {\n        uint16 peerChainId;\n        bytes32 peer;\n        (peerChainId, offset) = queries.asUint16CdUnchecked(offset);\n        (peer, offset) = queries.asBytes32CdUnchecked(offset);\n        ret = abi.encodePacked(ret, _isPeer(peerChainId, peer));\n      }\n      else if (query == CANONICAL_PEER_ID) {\n        uint16 peerChainId;\n        (peerChainId, offset) = queries.asUint16CdUnchecked(offset);\n        ret = abi.encodePacked(ret, _getCanonicalPeer(peerChainId));\n      }\n      else if (query == IS_CHAIN_SUPPORTED_ID) {\n        uint16 chainId;\n        (chainId, offset) = queries.asUint16CdUnchecked(offset);\n        ret = abi.encodePacked(ret, _isChainSupported(chainId));\n      }\n      else if (query == FEE_RECIPIENT_ID)\n        ret = abi.encodePacked(ret, _getFeeRecipient());\n      else\n        revert InvalidConfigQuery(query);\n    }\n\n    return (ret, offset);\n  }\n\n  function _getFeeRecipient() view internal returns(address payable) {\n    return configState().feeRecipient;\n  }\n\n  // ---- private ----\n\n  function _setFeeRecipient(address newFeeRecipient) internal {\n    senderAtLeastAdmin();\n\n    ConfigState storage state = configState();\n    address oldFeeRecipient = state.feeRecipient;\n    state.feeRecipient = payable(newFeeRecipient);\n    emit FeeRecipienUpdated(oldFeeRecipient, newFeeRecipient, block.timestamp);\n  }\n}\n"
    },
    "src/assets/TbrUser.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\nimport {CHAIN_ID_SOLANA} from \"wormhole-sdk/constants/Chains.sol\";\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {PermitParsing} from \"wormhole-sdk/libraries/PermitParsing.sol\";\nimport {fromUniversalAddress} from \"wormhole-sdk/Utils.sol\";\nimport {FREE_MEMORY_PTR} from \"wormhole-sdk/constants/Common.sol\";\nimport {IERC20Metadata} from \"wormhole-sdk/interfaces/token/IERC20Metadata.sol\";\nimport {IERC20Permit} from \"wormhole-sdk/interfaces/token/IERC20Permit.sol\";\nimport {SafeERC20} from \"wormhole-sdk/libraries/SafeERC20.sol\";\nimport {ISignatureTransfer, IAllowanceTransfer} from \"permit2/IPermit2.sol\";\nimport {\n  TRANSFER_TOKEN_WITH_RELAY_ID,\n  TRANSFER_GAS_TOKEN_WITH_RELAY_ID,\n  COMPLETE_TRANSFER_ID,\n  RELAY_FEE_ID,\n  BASE_RELAYING_CONFIG_ID,\n  APPROVE_TOKEN_ID\n} from \"./TbrIds.sol\";\nimport {TbrBase} from \"./TbrBase.sol\";\nimport {GasDropoff, BaseFee} from \"price-oracle/PriceOracleIntegration.sol\";\nimport {VaaLib} from \"wormhole-sdk/libraries/VaaLib.sol\";\nimport {TokenBridgeMessageLib} from \"wormhole-sdk/libraries/TokenBridgeMessages.sol\";\n\nuint8 constant TBR_V3_MESSAGE_VERSION = 0;\n\nuint8 constant ACQUIRE_PREAPPROVED = 0;\nuint8 constant ACQUIRE_PERMIT = 1;\nuint8 constant ACQUIRE_PERMIT2TRANSFER = 2;\nuint8 constant ACQUIRE_PERMIT2PERMIT = 3;\n\n// Solana computation units per relay.\nuint32 constant SOLANA_RELAY_COMPUTATION_UNITS = 385_000;\n// Solana signature count per relay.\n// Post VAA -> 3 txs\n//   7 Signature  verifications -> 2 signatures\n//   6 Signature  verifications -> 2 signatures\n//   Core verify signature set  -> 1 signature\n// Create user ATA              -> 1 signature\n// Redeem tx                    -> 1 signature\nuint8 constant SOLANA_RELAY_SIGNATURE_COUNT = 7;\n// Size of all accounts created during a relay to Solana.\nuint32 constant SOLANA_RELAY_TOTAL_SIZE_OF_ACCOUNTS =\n  //signatureSet\n  // see here: https://github.com/wormhole-foundation/wormhole/blob/91ec4d1dc01f8b690f0492815407505fb4587520/solana/bridge/program/src/accounts/signature_set.rs#L17\n  128 + // signatureSet account overhead\n    4 + // signatureSet vec length\n   19 + // signatureSet bool vec for 19 guardians\n   32 + // vaa hash\n    4 + // guardianSet\n  // PostedVAA\n  // see here: https://github.com/wormhole-foundation/wormhole/blob/91ec4d1dc01f8b690f0492815407505fb4587520/solana/bridge/program/src/accounts/posted_vaa.rs#L39\n  // and here: https://github.com/wormhole-foundation/wormhole/blob/91ec4d1dc01f8b690f0492815407505fb4587520/solana/bridge/program/src/accounts/posted_message.rs#L46\n  // and here: https://github.com/wormhole-foundation/wormhole/blob/91ec4d1dc01f8b690f0492815407505fb4587520/solana/modules/token_bridge/program/src/messages.rs#L175\n  128 + // PostedVaa account overhead\n    3 + // discriminator\n    1 + // vaa version\n    1 + // consistency level\n    4 + // vaa timestamp\n   32 + // signature account address\n    4 + // submission_time (waste)\n    4 + // nonce\n    8 + // sequence\n    2 + // emitterChain\n    4 + // payload vec length\n    1 + // payload id\n   32 + // token amount\n   32 + // token origin address\n    2 + // token origin chain\n   32 + // token bridge recipient address\n    2 + // recipient chain\n   32 + // from(=peer) address\n    1 + // tbrv3 version\n   32 + // recipient address\n    4 + // gas dropoff\n    1 + // unwrap intent*/ +\n  //ATA (should sum up to 165)\n  // see here https://github.com/solana-labs/solana-program-library/blob/6d92f4537a8dc278285abd66d93e7d49caaca0c5/token/program/src/state.rs#L89\n  128 + // ATA account overhead\n   32 + // associated mint\n   32 + // owner\n    8 + // amount\n    4 + // COption prefix (0 or 1, 4 bytes, waste) - see https://github.com/solana-labs/solana-program-library/blob/6d92f4537a8dc278285abd66d93e7d49caaca0c5/token/program/src/state.rs#L267\n   32 + // delegate COption<Pubkey>\n    1 + // account state enum\n    4 + // COoption prefix\n    8 + // is_native COption<u64>\n    8 + // delegated amount\n    4 + // COoption prefix\n   32;  // close authority COption<Pubkey>\n\n// Gas cost of a single `complete transfer` method execution.\nuint32 constant EVM_RELAY_GAS_COST = 333_164;\n// Size of the transaction in bytes.\nuint32 constant EVM_RELAY_TX_SIZE = 1212;\n// Amount of WEI in a microeth\nuint256 constant WEI_PER_MICROETH = 1E12;\n\n/**\n * There are no peers in the target chain.\n */\nerror TargetChainIsNotSupported(uint16 targetChain);\n/**\n * Transfers to the target chain are paused.\n */\nerror TransfersToChainArePaused(uint16 targetChain);\n/**\n * The gas dropoff requested exceeds the threshold for this particular chain.\n */\nerror GasDropoffRequestedExceedsMaximum(uint32 maxGasDropoff, uint commandIndex);\n/**\n * The attached gas token value does not cover the relay fee.\n */\nerror FeesInsufficient(uint256 feeReceived, uint commandIndex);\n/**\n * The acquire mode is not implemented at this time.\n */\nerror InvalidAcquireMode(uint8 acquireMode);\n/**\n * The incoming TBR payload had an unsupported version.\n */\nerror InvalidMsgVersion(uint8 version, uint commandIndex);\n/**\n * The incoming VAA has an invalid length.\n */\nerror InvalidVaaLength(uint commandIndex);\n/**\n * The incoming TB message was sent from an unknown contract.\n */\nerror UnrecognizedPeer(uint16 sourceChain, bytes32 sourceAddress, uint commandIndex);\n/**\n * The complete transfer command was supplied with insufficient gas tokens.\n */\nerror InsufficientGasDropoff(uint commandIndex);\n/**\n * The token transfer cannot be completed because the token is not attested on this chain yet.\n */\nerror TokenNotAttested(bytes32 canonicalToken, uint16 canonicalChain);\n/**\n * The gas token in this chain has no supported ERC20 tokenization.\n */\nerror GasTokenNotSupported();\n/**\n * The gas token is only accepted through ERC20 tokenization withdrawals.\n */\nerror GasTokenOnlyAcceptedViaWithdrawal();\n/**\n * The token recipient cannot be the zero address.\n */\nerror InvalidTokenRecipient();\n/**\n * The token amount cannot be zero.\n */\nerror InvalidTokenAmount();\n/**\n * The calculated fee is too large to be handled.\n */\nerror FeeTooLarge(uint256 totalFee, uint commandIndex);\n\nerror PayFailure(uint commandIndex, bytes bubbledUpError);\n\nfunction pay(\n  address payable callee,\n  uint256 value,\n  uint commandIndex\n) {\n  bytes4 selector = PayFailure.selector;\n  /// @solidity memory-safe-assembly\n  assembly {\n    let success := call(gas(), callee, value, 0, 0, 0, 0)\n    switch success\n    case 0 {\n      let freeMemory := mload(FREE_MEMORY_PTR)\n      mstore(freeMemory, selector)\n      mstore(add(freeMemory, 4), commandIndex)\n      let returnedDataSize := returndatasize()\n      mstore(add(freeMemory, 36), returnedDataSize)\n      returndatacopy(add(freeMemory, 68), 0, returnedDataSize)\n      let errorSize := add(returnedDataSize, 68)\n      revert(freeMemory, errorSize)\n    } default {}\n  }\n}\n\nevent TransferRequested(address sender, uint64 sequence, uint32 gasDropoff, uint256 fee);\n\nabstract contract TbrUser is TbrBase {\n  using BytesParsing for bytes;\n\n  function _transferTokenWithRelay(\n    bytes calldata data,\n    uint offset,\n    uint256 unallocatedBalance,\n    uint commandIndex\n  ) internal returns (uint256, uint256, uint256) {\n    uint16 targetChain; bytes32 recipient; uint32 gasDropoff; uint256 tokenAmount;\n    (targetChain, recipient, gasDropoff, tokenAmount, offset) = _parseSharedParams(data, offset);\n    address rawToken; bool unwrapIntent;\n    (rawToken,     offset) = data.asAddressCdUnchecked(offset);\n    (unwrapIntent, offset) = data.asBoolCdUnchecked(offset);\n    IERC20Metadata token = IERC20Metadata(rawToken);\n    (bytes32 peer, uint256 finalTokenAmount, uint256 fee, uint256 wormholeFee) =\n      _getAndCheckTransferParams(targetChain, recipient, token, tokenAmount, gasDropoff, commandIndex);\n\n    offset = _acquireTokens(data, offset, token, finalTokenAmount);\n\n    if (fee + wormholeFee > unallocatedBalance)\n      revert FeesInsufficient(msg.value, commandIndex);\n\n    _bridgeOut(token, targetChain, peer, recipient, finalTokenAmount, gasDropoff, unwrapIntent, fee, wormholeFee);\n\n    // Return the fee that must be sent to the fee recipient.\n    // TODO: should we return the sequence to the caller too?\n    // We shouldn't do so until we can efficiently allocate the memory for the result though.\n    return (fee, wormholeFee, offset);\n  }\n\n  function _transferGasTokenWithRelay(\n    bytes calldata data,\n    uint offset,\n    uint256 unallocatedBalance,\n    uint commandIndex\n  ) internal returns (uint256, uint256, uint256) {\n    if (address(gasToken) == address(0))\n      revert GasTokenNotSupported();\n\n    uint16 targetChain; bytes32 recipient; uint32 gasDropoff; uint256 tokenAmount;\n    (targetChain, recipient, gasDropoff, tokenAmount, offset) = _parseSharedParams(data, offset);\n\n    (bytes32 peer, uint256 finalTokenAmount, uint256 fee, uint256 wormholeFee) =\n      _getAndCheckTransferParams(\n        targetChain,\n        recipient,\n        IERC20Metadata(address(gasToken)),\n        tokenAmount,\n        gasDropoff,\n        commandIndex\n      );\n\n    if (fee + finalTokenAmount + wormholeFee > unallocatedBalance)\n      revert FeesInsufficient(msg.value, commandIndex);\n\n    // Tokenize\n    // Celo provides an ERC20 interface for its native token that doesn't require retokenization.\n    if (gasErc20TokenizationIsExplicit)\n      gasToken.deposit{value: finalTokenAmount}();\n\n    IERC20Metadata token = IERC20Metadata(address(gasToken));\n    _bridgeOut(\n      token,\n      targetChain,\n      peer,\n      recipient,\n      finalTokenAmount,\n      gasDropoff,\n      false,\n      fee,\n      wormholeFee\n    );\n\n    // Return the fee that must be sent to the fee recipient.\n    return (fee, finalTokenAmount + wormholeFee, offset);\n  }\n\n  function _parseSharedParams(\n    bytes calldata data,\n    uint offset\n  ) internal pure returns (\n    uint16  targetChain,\n    bytes32 recipient,\n    uint32  gasDropoff,\n    uint256 inputAmount,\n    uint    //offset\n  ) {\n    (targetChain, offset) = data.asUint16CdUnchecked(offset);\n    (recipient,   offset) = data.asBytes32CdUnchecked(offset);\n    (gasDropoff,  offset) = data.asUint32CdUnchecked(offset);\n    (inputAmount, offset) = data.asUint256CdUnchecked(offset);\n    return (targetChain, recipient, gasDropoff, inputAmount, offset);\n  }\n\n  //TODO this also needs to go into a shared library of some kind\n  function _acquireTokens(\n    bytes calldata data,\n    uint offset,\n    IERC20Metadata token,\n    uint256 finalTokenAmount\n  ) internal returns (uint) {\n    // Acquire tokens\n    uint8 acquireMode;\n    (acquireMode, offset) = data.asUint8CdUnchecked(offset);\n    if (acquireMode == ACQUIRE_PREAPPROVED)\n      SafeERC20.safeTransferFrom(token, msg.sender, address(this), finalTokenAmount);\n    else if (acquireMode == ACQUIRE_PERMIT) {\n      uint256 value; uint256 deadline; bytes32 r; bytes32 s; uint8 v;\n      (value, deadline, r, s, v, offset) =\n        PermitParsing.decodePermitCdUnchecked(data, offset);\n      //allow failure to prevent front-running griefing attacks\n      //  (i.e. getting permit from mempool and submitting it to the token contract directly)\n      try\n        IERC20Permit(address(token)).permit(msg.sender, address(this), value, deadline, v, r, s) {}\n      catch {}\n\n      // We only acquire the normalized `finalTokenAmount`\n      SafeERC20.safeTransferFrom(token, msg.sender, address(this), finalTokenAmount);\n    }\n    else if (acquireMode == ACQUIRE_PERMIT2TRANSFER) {\n      uint256 amount; uint256 nonce; uint256 sigDeadline; bytes memory signature;\n      (amount, nonce, sigDeadline, signature, offset) =\n        PermitParsing.decodePermit2TransferCdUnchecked(data, offset);\n\n      permit2.permitTransferFrom(\n        ISignatureTransfer.PermitTransferFrom({\n          permitted: ISignatureTransfer.TokenPermissions(address(token), amount),\n          nonce: nonce,\n          deadline: sigDeadline\n        }),\n        ISignatureTransfer.SignatureTransferDetails({\n          to: address(this),\n          requestedAmount: finalTokenAmount\n        }),\n        msg.sender,\n        signature\n      );\n    }\n    else if (acquireMode == ACQUIRE_PERMIT2PERMIT) {\n      uint160 amount; uint48 expiration; uint48 nonce; uint256 sigDeadline; bytes memory signature;\n      (amount, expiration, nonce, sigDeadline, signature, offset) =\n        PermitParsing.decodePermit2PermitCdUnchecked(data, offset);\n      //allow failure to prevent front-running griefing attacks\n      try\n        permit2.permit(\n          msg.sender,\n          IAllowanceTransfer.PermitSingle({\n            details: IAllowanceTransfer.PermitDetails(\n              address(token),\n              amount,\n              expiration,\n              nonce\n            ),\n            spender: address(this),\n            sigDeadline: sigDeadline\n          }),\n          signature\n        ) {}\n      catch {}\n      permit2.transferFrom(msg.sender, address(this), uint160(finalTokenAmount), address(token));\n    }\n    else\n      revert InvalidAcquireMode(acquireMode);\n\n    return offset;\n  }\n\n  function _getAndCheckTransferParams(\n    uint16 targetChain,\n    bytes32 recipient,\n    IERC20Metadata token,\n    uint256 tokenAmount,\n    uint32 gasDropoff,\n    uint commandIndex\n  ) internal view returns (bytes32, uint256, uint256, uint256) {\n    (bytes32 peer, uint32 baseFee, uint32 maxGasDropoff, bool paused) =\n      _getTargetChainData(targetChain);\n\n    if (peer == bytes32(0))\n      revert TargetChainIsNotSupported(targetChain);\n\n    if (paused)\n      revert TransfersToChainArePaused(targetChain);\n\n    if (gasDropoff > maxGasDropoff)\n      revert GasDropoffRequestedExceedsMaximum(maxGasDropoff, commandIndex);\n\n    if (recipient == bytes32(0))\n      revert InvalidTokenRecipient();\n\n    uint8 decimals = token.decimals();\n    uint256 cleanedTokenAmount = deNormalizeAmount(\n      normalizeAmount(tokenAmount, decimals),\n      decimals\n    );\n\n    if (cleanedTokenAmount == 0)\n      revert InvalidTokenAmount();\n\n    (uint256 fee, uint256 wormholeFee) = _quoteRelay(targetChain, gasDropoff, baseFee);\n\n    return (peer, cleanedTokenAmount, fee, wormholeFee);\n  }\n\n  function normalizeAmount(uint256 amount, uint8 decimals) internal pure returns(uint256) { unchecked {\n    if (decimals > 8) {\n      amount /= 10 ** (decimals - 8);\n    }\n    return amount;\n  }}\n\n  function deNormalizeAmount(uint256 amount, uint8 decimals) internal pure returns(uint256) { unchecked {\n    if (decimals > 8) {\n      amount *= 10 ** (decimals - 8);\n    }\n    return amount;\n  }}\n\n  /**\n   * @return fee in gas tokens with 18 decimals (i.e. wei)\n   * @return wormhole fee in gas tokens with 18 decimals (i.e. wei)\n   */\n  function _quoteRelay(\n    uint16 targetChain,\n    uint32 gasDropoff,\n    uint32 baseFee\n  ) view internal returns (uint256, uint256) {\n    uint wormholeFee = wormholeCore.messageFee();\n    if (targetChain == CHAIN_ID_SOLANA)\n      return (\n        _solanaTransactionQuote(\n          GasDropoff.wrap(gasDropoff),\n          SOLANA_RELAY_COMPUTATION_UNITS,\n          SOLANA_RELAY_TOTAL_SIZE_OF_ACCOUNTS,\n          SOLANA_RELAY_SIGNATURE_COUNT,\n          BaseFee.wrap(baseFee)\n        ),\n        wormholeFee\n      );\n\n    return (\n        _evmTransactionQuote(\n          targetChain,\n          GasDropoff.wrap(gasDropoff),\n          EVM_RELAY_GAS_COST,\n          BaseFee.wrap(baseFee),\n          EVM_RELAY_TX_SIZE\n        ),\n        wormholeFee\n    );\n  }\n\n  function _bridgeOut(\n    IERC20Metadata token,\n    uint16 targetChain,\n    bytes32 peer,\n    bytes32 recipient,\n    uint256 tokenAmount,\n    uint32 gasDropoff,\n    bool unwrapIntent,\n    uint256 fee,\n    uint256 wormholeFee\n  ) private {\n    bytes memory tbrMessage = _tbrv3Message(recipient, gasDropoff, unwrapIntent);\n    // Perform call to token bridge. This requires previous approval of the tokens.\n    uint64 sequence = tokenBridge.transferTokensWithPayload{value: wormholeFee}(\n      address(token),\n      tokenAmount,\n      targetChain,\n      peer,\n      0,\n      tbrMessage\n    );\n\n    emit TransferRequested(msg.sender, sequence, gasDropoff, fee);\n  }\n\n  function _approveToken(\n    bytes calldata data,\n    uint offset\n  ) internal returns (uint256) { unchecked {\n    address token;\n    uint retOffset;\n    (token, retOffset) = data.asAddressCdUnchecked(offset);\n\n    SafeERC20.forceApprove(IERC20Metadata(token), address(tokenBridge), type(uint256).max);\n\n    return retOffset;\n  }}\n\n  function _tbrv3Message(\n    bytes32 recipient,\n    uint32 gasDropoff,\n    bool unwrapIntent\n  ) internal pure returns (bytes memory) {\n    // From low byte offset to high byte offset:\n    // 1 byte version\n    // 32 byte recipient\n    // 4 byte gas dropoff, in µToken units.\n    // 1 byte unwrap intent\n    return abi.encodePacked(\n      TBR_V3_MESSAGE_VERSION,\n      recipient,\n      gasDropoff,\n      unwrapIntent\n    );\n  }\n\n  function _allowanceTokenBridge(\n    bytes calldata data,\n    uint offset\n  ) internal view returns (bytes memory, uint) {\n    address token; uint retOffset;\n    (token, retOffset) = data.asAddressCdUnchecked(offset);\n    uint256 allowance = _allowanceTokenBridgeImpl(token);\n\n    return (abi.encodePacked(allowance), retOffset);\n  }\n\n  function _allowanceTokenBridgeImpl(\n    address token\n  ) internal view returns (uint256) {\n    return IERC20Metadata(token).allowance(address(this), address(tokenBridge));\n  }\n\n  function _completeTransfer(\n    bytes calldata data,\n    uint offset,\n    uint256 unallocatedBalance,\n    uint commandIndex\n  ) internal returns (uint256, uint) { unchecked {\n    ( bytes calldata vaa,\n      uint16 peerChain,\n      bytes32 peerAddress,\n      uint16 tokenOriginChain,\n      bytes32 tokenOriginAddress,\n      address recipient,\n      uint256 tbNormalizedTokenAmount,\n      uint32 gasDropoff,\n      bool unwrapIntent,\n      uint retOffset\n    ) = _parseRedeem(data, offset, commandIndex);\n\n    if (!_isPeer(peerChain, peerAddress))\n      revert UnrecognizedPeer(peerChain, peerAddress, commandIndex);\n\n    // If the recipient redeems manually it doesn't need the gasDropoff\n    if (msg.sender == recipient)\n      gasDropoff = 0;\n\n    // The dropoff in the message is measured in microeth so we should convert it to wei first\n    uint256 gasDropoffInWei = gasDropoff * WEI_PER_MICROETH;\n\n    if (gasDropoffInWei > unallocatedBalance)\n      revert InsufficientGasDropoff(commandIndex);\n\n    // Some tokens might implement distributed supply expansion / contraction.\n    // We don't treat those specially so they are not supported and may break.\n\n    // Perform redeem in TB\n    tokenBridge.completeTransferWithPayload(vaa);\n\n    address token;\n    if (whChainId != tokenOriginChain) {\n      token = tokenBridge.wrappedAsset(tokenOriginChain, tokenOriginAddress);\n    } else {\n      token = fromUniversalAddress(tokenOriginAddress);\n    }\n\n    uint8 decimals = IERC20Metadata(token).decimals();\n    uint256 tokenAmount = deNormalizeAmount(tbNormalizedTokenAmount, decimals);\n\n    // If an unwrap is desired, unwrap and call recipient with full amount\n    uint totalGasTokenAmount = gasDropoffInWei;\n    if (address(gasToken) == token && unwrapIntent && gasErc20TokenizationIsExplicit) {\n      gasToken.withdraw(tokenAmount);\n\n      totalGasTokenAmount += tokenAmount;\n    }\n    else {\n      // Otherwise, transfer tokens and perform gas dropoff\n      SafeERC20.safeTransfer(IERC20Metadata(token), recipient, tokenAmount);\n    }\n    if (totalGasTokenAmount > 0) {\n      // FIXME: we need to put an upper bound on the read bytes to ensure that the contract doesn't run out of gas.\n      pay(payable(recipient), totalGasTokenAmount, commandIndex);\n    }\n\n    return (gasDropoffInWei, retOffset);\n  }}\n\n  /**\n   * Returns the relay fee in gas token Mwei.\n   */\n  function _relayFee(\n    bytes calldata data,\n    uint offset,\n    uint commandIndex\n  ) internal view returns(bytes memory, uint256) {\n    uint16 chainId;\n    uint32 gasDropoff;\n    (chainId,    offset) = data.asUint16CdUnchecked(offset);\n    (gasDropoff, offset) = data.asUint32CdUnchecked(offset);\n\n    (, uint32 baseFee, uint32 maxGasDropoff, bool paused) =\n      _getTargetChainData(chainId);\n\n    if (gasDropoff > maxGasDropoff)\n      revert GasDropoffRequestedExceedsMaximum(maxGasDropoff, commandIndex);\n\n    (uint relayFee, uint wormholeFee) = _quoteRelay(chainId, gasDropoff, baseFee);\n    uint totalFee = (relayFee + wormholeFee) / _TOTAL_FEE_DIVISOR;\n    // We need to round up to ensure that the quoted relay fee is able to cover the remainder.\n    if ((relayFee + wormholeFee) % _TOTAL_FEE_DIVISOR > 0)\n      ++totalFee;\n    if (totalFee > type(uint64).max)\n      revert FeeTooLarge(totalFee, commandIndex);\n\n    return (abi.encodePacked(paused, uint64(totalFee)), offset);\n  }\n\n  function _baseRelayingConfig(\n    bytes calldata data,\n    uint offset,\n    uint\n  ) internal view returns(bytes memory, uint256) {\n    uint16 chainId;\n    (chainId, offset) = data.asUint16CdUnchecked(offset);\n    (bytes32 peer, uint32 baseFee, uint32 maxGasDropoff, bool paused) =\n      _getTargetChainData(chainId);\n\n    return (abi.encodePacked(peer, baseFee, maxGasDropoff, paused), offset);\n  }\n\n  function _parseRedeem(\n    bytes calldata data,\n    uint offset,\n    uint commandIndex\n  ) internal pure returns(\n    bytes calldata vaa,\n    uint16 peerChain,\n    bytes32 peerAddress,\n    uint16 tokenOriginChain,\n    bytes32 tokenOriginAddress,\n    address recipient,\n    uint256 tbNormalizedTokenAmount,\n    uint32 gasDropoff,\n    bool unwrapIntent,\n    uint retOffset\n  ) { unchecked {\n    (vaa, retOffset) = data.sliceUint16PrefixedCdUnchecked(offset);\n    bytes calldata vaaPayload;\n    (peerChain, vaaPayload) = VaaLib.decodeEmitterChainAndPayloadCdUnchecked(vaa);\n    // Note that the token amount is expressed in at most 8 decimals so\n    // you need to denormalize this amount before calling transfer functions on the token.\n\n    bytes calldata payload;\n    ( tbNormalizedTokenAmount, \n      tokenOriginAddress, \n      tokenOriginChain, \n      peerAddress, \n      payload\n    ) = TokenBridgeMessageLib.decodeTransferWithPayloadEssentialsCd(vaaPayload);\n\n    uint payloadOffset = 0;\n    uint8 tbrV3Version;\n    (tbrV3Version, payloadOffset) = payload.asUint8CdUnchecked(payloadOffset);\n    if (tbrV3Version != TBR_V3_MESSAGE_VERSION)\n      revert InvalidMsgVersion(tbrV3Version, commandIndex);\n\n    bytes32 universalRecipient;\n    (universalRecipient, payloadOffset) = payload.asBytes32CdUnchecked(payloadOffset);\n    recipient = fromUniversalAddress(universalRecipient);\n    (gasDropoff, payloadOffset) = payload.asUint32CdUnchecked(payloadOffset);\n    (unwrapIntent, payloadOffset) = payload.asBoolCdUnchecked(payloadOffset);\n    if (payloadOffset != payload.length)\n      revert InvalidVaaLength(commandIndex);\n  }}\n\n  receive() external payable {\n    // NOTE: all values retrieved here need to be immutables to avoid going over the 2300 gas stipend\n    if (!gasErc20TokenizationIsExplicit)\n      revert GasTokenNotSupported();\n\n    if (msg.sender != address(gasToken))\n      revert GasTokenOnlyAcceptedViaWithdrawal();\n  }\n}"
    },
    "lib/wormhole-solidity-sdk/src/components/dispatcher/Ids.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.4;\n\n// ----------- Dispatcher Ids -----------\n\n// Execute commands\n\nuint8 constant ACCESS_CONTROL_ID = 0x60;\nuint8 constant ACQUIRE_OWNERSHIP_ID = 0x61;\nuint8 constant UPGRADE_CONTRACT_ID = 0x62;\nuint8 constant SWEEP_TOKENS_ID = 0x63;\n\n// Query commands\n\nuint8 constant ACCESS_CONTROL_QUERIES_ID = 0xe0;\nuint8 constant IMPLEMENTATION_ID = 0xe1;\n\n// ----------- Access Control Ids -----------\n\n// Execute commands\n\n//admin:\nuint8 constant REVOKE_ADMIN_ID = 0x00;\n\n//owner only:\nuint8 constant PROPOSE_OWNERSHIP_TRANSFER_ID = 0x10;\nuint8 constant RELINQUISH_OWNERSHIP_ID = 0x11;\nuint8 constant ADD_ADMIN_ID = 0x12;\nuint8 constant CANCEL_OWNERSHIP_TRANSFER_ID = 0x13;\n\n// Query commands\n\nuint8 constant OWNER_ID = 0x80;\nuint8 constant PENDING_OWNER_ID = 0x81;\nuint8 constant IS_ADMIN_ID = 0x82;\nuint8 constant ADMINS_ID = 0x83;"
    },
    "src/assets/TbrIds.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\n// ----------- Dispatcher Ids -----------\n\nuint8 constant DISPATCHER_PROTOCOL_VERSION0 = 0;\n\n// Execute commands\n\nuint8 constant TRANSFER_TOKEN_WITH_RELAY_ID = 0x00;\nuint8 constant TRANSFER_GAS_TOKEN_WITH_RELAY_ID = 0x01;\nuint8 constant COMPLETE_TRANSFER_ID = 0x02;\nuint8 constant CONFIG_ID = 0x03;\nuint8 constant APPROVE_TOKEN_ID = 0x04;\n\n// Query commands\n\nuint8 constant RELAY_FEE_ID = 0x80;\nuint8 constant BASE_RELAYING_CONFIG_ID = 0x81;\nuint8 constant CONFIG_QUERIES_ID = 0x82;\nuint8 constant ALLOWANCE_TOKEN_BRIDGE_ID = 0x83;\nuint8 constant GAS_TOKEN_ID = 0x84;\nuint8 constant GAS_TOKEN_ALLOWANCE_TOKEN_BRIDGE_ID = 0x85;\n\n// ----------- Config Ids -----------\n\n// Execute commands\n\n// admin can add new peers, but only owner can change existing registrations\nuint8 constant ADD_PEER_ID = 0x00;\nuint8 constant UPDATE_BASE_FEE_ID = 0x01;\nuint8 constant UPDATE_MAX_GAS_DROPOFF_ID = 0x02;\nuint8 constant PAUSE_CHAIN_ID = 0x03;\n// gap for future chain parameters\n\nuint8 constant UPDATE_FEE_RECIPIENT_ID = 0x0a;\n// only available to owner:\nuint8 constant UPDATE_CANONICAL_PEER_ID = 0x0b;\n\n// Query commands\n\nuint8 constant IS_CHAIN_SUPPORTED_ID = 0x80;\nuint8 constant IS_CHAIN_PAUSED_ID = 0x81;\nuint8 constant BASE_FEE_ID = 0x82;\nuint8 constant MAX_GAS_DROPOFF_ID = 0x83;\nuint8 constant CANONICAL_PEER_ID = 0x84;\nuint8 constant IS_PEER_ID = 0x85;\nuint8 constant FEE_RECIPIENT_ID = 0x86;\n"
    },
    "../lib/relayer-infra-contracts/apps/price-oracle/evm/src/PriceOracleIntegration.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\nimport { BytesParsing } from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport { RawDispatcher} from \"wormhole-sdk/RawDispatcher.sol\";\nimport { reRevert } from \"wormhole-sdk/Utils.sol\";\nimport \"wormhole-sdk/components/dispatcher/Ids.sol\";\n\nimport { GasDropoff, BaseFee } from \"./assets/types/ParamLibs.sol\";\nimport { IPriceOracle } from \"./IPriceOracle.sol\";\nimport \"./assets/PriceOracleIds.sol\";\n\nerror InvalidAddress();\n\nabstract contract PriceOracleIntegration {\n  using BytesParsing for bytes;\n\n  address internal immutable _priceOracle;\n\n  constructor(address priceOracle) {\n    if (priceOracle == address(0))\n      revert InvalidAddress();\n\n    _priceOracle = priceOracle;\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // ------------------------------------------- Quotes --------------------------------------------\n  // -----------------------------------------------------------------------------------------------\n\n  /**\n   * @notice Get the quote for an EVM transaction.\n   * @dev See evmTransactionQuote in PriceOraclePrices for more details.\n   */\n  function _evmTransactionQuote(\n    uint16 targetChainId,\n    GasDropoff gasDropoff,\n    uint32 gas,\n    BaseFee baseFee,\n    uint32 billedBytes\n  ) internal view returns (uint quote) {\n    uint8 subcommandCount = 1;\n\n    (quote,) = _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        PRICES_QUERIES_ID,\n        subcommandCount,\n        EVM_TX_QUOTE_ID,\n        targetChainId,\n        gasDropoff,\n        gas,\n        baseFee,\n        billedBytes\n      )\n    ).asUint256MemUnchecked(0);\n  }\n\n  /**\n   * @notice Get the quote for a Solana transaction.\n   * @dev See solanaTransactionQuote in PriceOraclePrices for more details.\n   */\n  function _solanaTransactionQuote(\n    GasDropoff gasDropoff,\n    uint32 computationUnits,\n    uint32 totalSizeOfAccounts,\n    uint8 signatureCount,\n    BaseFee baseFee\n  ) internal view returns (uint quote) {\n    uint8 subcommandCount = 1;\n\n    (quote,) = _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        PRICES_QUERIES_ID,\n        subcommandCount,\n        SOLANA_TX_QUOTE_ID,\n        gasDropoff,\n        computationUnits,\n        totalSizeOfAccounts,\n        signatureCount,\n        baseFee\n      )\n    ).asUint256MemUnchecked(0);\n  }\n\n  /**\n   * @notice Get the quote for a Sui transaction.\n   * @dev See suiTransactionQuote in PriceOraclePrices for more details.\n   */\n  function _suiTransactionQuote(\n    GasDropoff gasDropoff,\n    uint32 computationUnits,\n    uint32 storageBytes,\n    uint32 rebateBytes,\n    BaseFee baseFee\n  ) internal view returns (uint quote) {\n    uint8 subcommandCount = 1;\n\n    (quote,) = _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        PRICES_QUERIES_ID,\n        subcommandCount,\n        SUI_TX_QUOTE_ID,\n        gasDropoff,\n        computationUnits,\n        storageBytes,\n        rebateBytes,\n        baseFee\n      )\n    ).asUint256MemUnchecked(0);\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // --------------------------------------- Getters & Utils ---------------------------------------\n  // -----------------------------------------------------------------------------------------------\n\n  // ---- Mutable Getters ----\n\n  function _oracleOwner() internal view returns (address) {\n    uint8 subcommandCount = 1;\n    return _getAddr(\n      abi.encodePacked(\n        ACCESS_CONTROL_QUERIES_ID,\n        subcommandCount,\n        OWNER_ID\n      )\n    );\n  }\n\n  function _oraclePendingOwner() internal view returns (address) {\n    uint8 subcommandCount = 1;\n    return _getAddr(\n      abi.encodePacked(\n        ACCESS_CONTROL_QUERIES_ID,\n        subcommandCount,\n        PENDING_OWNER_ID\n      )\n    );\n  }\n\n  function _oracleAssistant() internal view returns (address) {\n    return _getAddr(\n      abi.encodePacked(\n        ASSISTANT_ID\n      )\n    );\n  }\n\n  function _oracleImplementation() internal view returns (address) {\n    return _getAddr(\n      abi.encodePacked(     \n        IMPLEMENTATION_ID\n      )\n    );\n  }\n\n  function _oracleIsAdmin(address admin) internal view returns (bool isAdmin) {\n    uint8 subcommandCount = 1;\n    (isAdmin, ) = _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        ACCESS_CONTROL_QUERIES_ID,\n        subcommandCount,\n        IS_ADMIN_ID,\n        admin\n      )\n    ).asBoolMemUnchecked(0);\n  }\n\n  function _feeParams(uint16 chainId) internal view returns (uint256 data) {\n    uint8 subcommandCount = 1;\n    (data, ) = _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        PRICES_QUERIES_ID,\n        subcommandCount,\n        QUERY_FEE_PARAMS_ID,\n        uint16(chainId)\n      )\n    ).asUint256MemUnchecked(0);\n  }\n\n  function _oracleBatchGet(bytes memory data) internal view returns (bytes memory) {\n    return _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        data\n      )\n    );\n  }\n\n  // ---- Immutable Getters ----\n\n  function _oracleChainId() internal virtual returns (uint16 chainId) {\n    uint8 subcommandCount = 1;\n\n    (chainId, ) = _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        PRICES_QUERIES_ID,\n        subcommandCount,\n        CHAIN_ID_ID\n      )\n    ).asUint16MemUnchecked(0);\n  }\n\n  // -----------------------------------------------------------------------------------------------\n  // ------------------------------------------- Private -------------------------------------------\n  // -----------------------------------------------------------------------------------------------\n\n  function _invokeOracle(bytes memory encode) private view returns (bytes memory data) {\n    (bool success, bytes memory result) = address(_priceOracle).staticcall(encode);\n    if (!success)\n      reRevert(result);\n\n    (uint length,) = result.asUint256MemUnchecked(32);\n    (data,) = result.sliceMemUnchecked(64, length);\n  }\n\n  function _getAddr(bytes memory query) private view returns (address addr) {\n    (addr, ) = _invokeOracle(\n      abi.encodePacked(\n        IPriceOracle.get1959.selector,\n        DISPATCHER_PROTOCOL_VERSION0,\n        query\n      )\n    ).asAddressMemUnchecked(0);\n  }\n}"
    },
    "lib/permit2/src/interfaces/IEIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/Utils.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.4;\n\nimport {\n  tokenOrNativeTransfer\n} from \"wormhole-sdk/utils/Transfer.sol\";\nimport {\n  reRevert\n} from \"wormhole-sdk/utils/Revert.sol\";\nimport {\n  NotAnEvmAddress,\n  toUniversalAddress,\n  fromUniversalAddress\n} from \"wormhole-sdk/utils/UniversalAddress.sol\";\nimport {\n  keccak256Word,\n  keccak256SliceUnchecked,\n  keccak256Cd\n} from \"wormhole-sdk/utils/Keccak.sol\";\nimport {\n  eagerAnd,\n  eagerOr\n} from \"wormhole-sdk/utils/EagerOps.sol\";\n"
    },
    "lib/wormhole-solidity-sdk/src/components/dispatcher/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.4;\n\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {\n  ACCESS_CONTROL_ID,\n  ACCESS_CONTROL_QUERIES_ID,\n  OWNER_ID,\n  PENDING_OWNER_ID,\n  IS_ADMIN_ID,\n  ADMINS_ID,\n  REVOKE_ADMIN_ID,\n  ADD_ADMIN_ID,\n  PROPOSE_OWNERSHIP_TRANSFER_ID,\n  ACQUIRE_OWNERSHIP_ID,\n  RELINQUISH_OWNERSHIP_ID,\n  CANCEL_OWNERSHIP_TRANSFER_ID\n} from \"wormhole-sdk/components/dispatcher/Ids.sol\";\n\n//rationale for different roles (owner, admin):\n// * owner should be a mulit-sig / ultra cold wallet that is only activated in exceptional\n//     circumstances.\n// * admin should also be either a cold wallet or Admin contract. In either case,\n//     the expectation is that multiple, slightly less trustworthy parties than the owner will\n//     have access to it, lowering trust assumptions and increasing attack surface. Admins\n//     perform rare but not exceptional operations.\n\nstruct AccessControlState {\n  address   owner; //puts owner address in eip1967 admin slot\n  address   pendingOwner;\n  address[] admins;\n  mapping(address => uint256) isAdmin;\n}\n\n// we use the designated eip1967 admin storage slot:\n// keccak256(\"eip1967.proxy.admin\") - 1\nbytes32 constant ACCESS_CONTROL_STORAGE_SLOT =\n  0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\nfunction accessControlState() pure returns (AccessControlState storage state) {\n  assembly (\"memory-safe\") { state.slot := ACCESS_CONTROL_STORAGE_SLOT }\n}\n\nerror NotAuthorized();\nerror InvalidAccessControlCommand(uint8 command);\nerror InvalidAccessControlQuery(uint8 query);\n\nevent OwnerUpdated(address oldAddress, address newAddress, uint256 timestamp);\nevent AdminsUpdated(address addr, bool isAdmin, uint256 timestamp);\n\nenum Role {\n  None,\n  Owner,\n  Admin\n}\n\nfunction failAuthIf(bool condition) pure {\n  if (condition)\n    revert NotAuthorized();\n}\n\nfunction senderAtLeastAdmin() view returns (Role) {\n  Role role = senderRole();\n  failAuthIf(role == Role.None);\n\n  return role;\n}\n\nfunction senderRole() view returns (Role) {\n  AccessControlState storage state = accessControlState();\n  if (msg.sender == state.owner) //check highest privilege level first\n    return Role.Owner;\n\n  return state.isAdmin[msg.sender] != 0 ? Role.Admin : Role.None;\n}\n\nabstract contract AccessControl {\n  using BytesParsing for bytes;\n\n  // ---- construction ----\n\n  function _accessControlConstruction(\n    address owner,\n    address[] memory admins\n  ) internal {\n    AccessControlState storage state = accessControlState();\n    state.owner = owner;\n    for (uint i = 0; i < admins.length; ++i)\n      _updateAdmins(state, admins[i], true);\n  }\n\n  // ---- external -----\n\n  //selector: f2fde38b\n  function transferOwnership(address newOwner) external {\n    AccessControlState storage state = accessControlState();\n    if (msg.sender != state.owner)\n      revert NotAuthorized();\n\n    _proposeOwnershipTransfer(state, newOwner);\n  }\n\n  //selector: 23452b9c \n  function cancelOwnershipTransfer() external {\n    AccessControlState storage state = accessControlState();\n    if (msg.sender != state.owner)\n      revert NotAuthorized();\n\n    _cancelOwnershipTransfer(state);\n  }\n\n  //selector: 1c74a301\n  function receiveOwnership() external {\n    _acquireOwnership();\n  }\n\n  // ---- internals ----\n\n  /**\n   * Dispatch an execute function. Execute functions almost always modify contract state.\n   */\n  function dispatchExecAccessControl(\n    bytes calldata data,\n    uint offset,\n    uint8 command\n  ) internal returns (bool, uint) {\n    if (command == ACCESS_CONTROL_ID)\n      offset = _batchAccessControlCommands(data, offset);\n    else if (command == ACQUIRE_OWNERSHIP_ID)\n      _acquireOwnership();\n    else\n      return (false, offset);\n\n    return (true, offset);\n  }\n\n  /**\n   * Dispatch a query function. Query functions never modify contract state.\n   */\n  function dispatchQueryAccessControl(\n    bytes calldata data,\n    uint offset,\n    uint8 query\n  ) view internal returns (bool, bytes memory, uint) {\n    bytes memory result;\n    if (query == ACCESS_CONTROL_QUERIES_ID)\n      (result, offset) = _batchAccessControlQueries(data, offset);\n    else\n      return (false, new bytes(0), offset);\n\n    return (true, result, offset);\n  }\n\n  function _batchAccessControlCommands(\n    bytes calldata commands,\n    uint offset\n  ) internal returns (uint) {\n    AccessControlState storage state = accessControlState();\n    bool isOwner = senderAtLeastAdmin() == Role.Owner;\n\n    uint remainingCommands;\n    (remainingCommands, offset) = commands.asUint8CdUnchecked(offset);\n    for (uint i = 0; i < remainingCommands; ++i) {\n      uint8 command;\n      (command, offset) = commands.asUint8CdUnchecked(offset);\n      if (command == REVOKE_ADMIN_ID) {\n        address admin;\n        (admin, offset) = commands.asAddressCdUnchecked(offset);\n        _updateAdmins(state, admin, false);\n      }\n      else {\n        if (!isOwner)\n          revert NotAuthorized();\n\n        if (command == ADD_ADMIN_ID) {\n          address newAdmin;\n          (newAdmin, offset) = commands.asAddressCdUnchecked(offset);\n          _updateAdmins(state, newAdmin, true);\n        }\n        else if (command == PROPOSE_OWNERSHIP_TRANSFER_ID) {\n          address newOwner;\n          (newOwner, offset) = commands.asAddressCdUnchecked(offset);\n\n          _proposeOwnershipTransfer(state, newOwner);\n        }\n        else if (command == CANCEL_OWNERSHIP_TRANSFER_ID) {\n          _cancelOwnershipTransfer(state);\n        }\n        else if (command == RELINQUISH_OWNERSHIP_ID) {\n          _relinquishOwnership(state);\n\n          //ownership relinquishment must be the last command in the batch\n          BytesParsing.checkLength(offset, commands.length);\n        }\n        else\n          revert InvalidAccessControlCommand(command);\n      }\n    }\n    return offset;\n  }\n\n  function _batchAccessControlQueries(\n    bytes calldata queries,\n    uint offset\n  ) internal view returns (bytes memory, uint) {\n    AccessControlState storage state = accessControlState();\n    bytes memory ret;\n\n    uint remainingQueries;\n    (remainingQueries, offset) = queries.asUint8CdUnchecked(offset);\n    for (uint i = 0; i < remainingQueries; ++i) {\n      uint8 query;\n      (query, offset) = queries.asUint8CdUnchecked(offset);\n\n      if (query == IS_ADMIN_ID) {\n        address admin;\n        (admin, offset) = queries.asAddressCdUnchecked(offset);\n        ret = abi.encodePacked(ret, state.isAdmin[admin] != 0);\n      }\n      else if (query == ADMINS_ID) {\n        ret = abi.encodePacked(ret, uint8(state.admins.length));\n        for (uint j = 0; j < state.admins.length; ++j)\n          ret = abi.encodePacked(ret, state.admins[j]);\n      }\n      else {\n        address addr;\n        if (query == OWNER_ID)\n          addr = state.owner;\n        else if (query == PENDING_OWNER_ID)\n          addr = state.pendingOwner;\n        else\n          revert InvalidAccessControlQuery(query);\n\n        ret = abi.encodePacked(ret, addr);\n      }\n    }\n\n    return (ret, offset);\n  }\n\n  // ---- private ----\n\n  function _acquireOwnership() private {\n    AccessControlState storage state = accessControlState();\n    if (state.pendingOwner != msg.sender)\n      revert NotAuthorized();\n\n    _updateOwner(state, msg.sender);\n  }\n\n  function _relinquishOwnership(AccessControlState storage state) private {\n    _updateOwner(state, address(0));\n  }\n\n  function _updateOwner(AccessControlState storage state, address newOwner) private {\n    address oldAddress = state.owner;\n    state.owner = newOwner;\n    state.pendingOwner = address(0);\n\n    emit OwnerUpdated(oldAddress, newOwner, block.timestamp);\n  }\n\n  function _proposeOwnershipTransfer(AccessControlState storage state, address newOwner) private {\n    state.pendingOwner = newOwner;\n  }\n\n  function _cancelOwnershipTransfer(AccessControlState storage state) private {\n    state.pendingOwner = address(0);\n  }\n\n  function _updateAdmins(\n    AccessControlState storage state, \n    address admin, \n    bool authorization\n  ) private { unchecked {\n    if ((state.isAdmin[admin] != 0) == authorization)\n      return;\n\n    if (authorization) {\n      state.admins.push(admin);\n      state.isAdmin[admin] = state.admins.length;\n    }\n    else {\n      uint256 rawIndex = state.isAdmin[admin];\n      if (rawIndex != state.admins.length) {\n        address tmpAdmin = state.admins[state.admins.length - 1];\n        state.isAdmin[tmpAdmin] = rawIndex;\n        state.admins[rawIndex - 1] = tmpAdmin;\n      }\n\n      state.isAdmin[admin] = 0;\n      state.admins.pop();\n    }\n\n    emit AdminsUpdated(admin, authorization, block.timestamp);\n  }}\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.4;\n\nimport {IERC20} from \"IERC20/IERC20.sol\";\nimport {WORD_SIZE, SCRATCH_SPACE_PTR} from \"wormhole-sdk/constants/Common.sol\";\n\n//Like OpenZeppelin's SafeERC20.sol, but slimmed down and more gas efficient.\n//\n//The main difference to OZ's implementation (besides the missing functions) is that we skip the\n//  EXTCODESIZE check that OZ does upon successful calls to ensure that an actual contract was\n//  called. The rationale for omitting this check is that ultimately the contract using the token\n//  has to verify that it \"makes sense\" for its use case regardless. Otherwise, a random token, or\n//  even just a contract that always returns true, could be passed, which makes this check\n//  superfluous in the final analysis.\n//\n//We also save on code size by not duplicating the assembly code in two separate functions.\n//  Otoh, we simply swallow revert reasons of failing token operations instead of bubbling them up.\n//  This is less clean and makes debugging harder, but is likely still a worthwhile trade-off\n//    given the cost in gas and code size.\nlibrary SafeERC20 {\n  error SafeERC20FailedOperation(address token);\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _revertOnFailure(token, abi.encodeCall(token.transfer, (to, value)));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _revertOnFailure(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n  }\n\n  function forceApprove(IERC20 token, address spender, uint256 value) internal {\n    bytes memory approveCall = abi.encodeCall(token.approve, (spender, value));\n\n    if (!_callWithOptionalReturnCheck(token, approveCall)) {\n      _revertOnFailure(token, abi.encodeCall(token.approve, (spender, 0)));\n      _revertOnFailure(token, approveCall);\n    }\n  }\n\n  function _callWithOptionalReturnCheck(\n    IERC20 token,\n    bytes memory encodedCall\n  ) private returns (bool success) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(SCRATCH_SPACE_PTR, 0)\n      success := call( //see https://www.evm.codes/?fork=cancun#f1\n        gas(),                       //gas\n        token,                       //callee\n        0,                           //value\n        add(encodedCall, WORD_SIZE), //input ptr\n        mload(encodedCall),          //input size\n        SCRATCH_SPACE_PTR,           //output ptr\n        WORD_SIZE                    //output size\n      )\n      //calls to addresses without code are always successful\n      if success {\n        success := or(iszero(returndatasize()), mload(SCRATCH_SPACE_PTR))\n      }\n    }\n  }\n\n  function _revertOnFailure(IERC20 token, bytes memory encodedCall) private {\n    if (!_callWithOptionalReturnCheck(token, encodedCall))\n      revert SafeERC20FailedOperation(address(token));\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/proxy/ProxyBase.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.24;\n\nimport {implementationState} from \"./Eip1967Implementation.sol\";\n\nerror InvalidSender();\nerror IdempotentUpgrade();\nerror InvalidMsgValue();\nerror InvalidData();\nerror InvalidImplementation();\nerror UpgradeFailed(bytes revertData);\n\nevent Upgraded(address indexed implementation);\n\n//works with both standard EIP1967 proxies and our own, slimmed down Proxy contract\nabstract contract ProxyBase {\n  //address private immutable _logicContract = address(this);\n\n  //payable for proxyConstructor use case\n  //selector: f4189c473\n  function checkedUpgrade(bytes calldata data) payable external {\n    if (msg.sender != address(this)) {\n      if (implementationState().initialized)\n        revert InvalidSender();\n\n      _proxyConstructor(data);\n    }\n    else\n      _contractUpgrade(data);\n\n    //If we upgrade from an old OpenZeppelin proxy, then initialized will not have been set to true\n    //  even though the constructor has been called, so we simply manually set it here in all cases.\n    //This is slightly gas inefficient but better to be safe than sorry for rare use cases like\n    //  contract upgrades.\n    implementationState().initialized = true;\n  }\n\n  //msg.value should be enforced/checked before calling _upgradeTo\n  function _upgradeTo(address newImplementation, bytes memory data) internal {\n    if (newImplementation == implementationState().implementation)\n      revert IdempotentUpgrade();\n\n    if (newImplementation.code.length == 0)\n      revert InvalidImplementation();\n\n    implementationState().implementation = newImplementation;\n\n    (bool success, bytes memory revertData) =\n      address(this).call(abi.encodeCall(this.checkedUpgrade, (data)));\n\n    if (!success)\n      revert UpgradeFailed(revertData);\n\n    emit Upgraded(newImplementation);\n  }\n\n  function _getImplementation() internal view returns (address) {\n    return implementationState().implementation;\n  }\n\n  function _proxyConstructor(bytes calldata data) internal virtual {\n    if (msg.value > 0)\n      revert InvalidMsgValue();\n\n    _noDataAllowed(data);\n\n    //!!don't forget to check/enforce msg.value when overriding!!\n  }\n\n  function _contractUpgrade(bytes calldata data) internal virtual {\n    _noDataAllowed(data);\n\n    //override and implement in the new logic contract (if required)\n  }\n\n  function _noDataAllowed(bytes calldata data) internal pure {\n    if (data.length > 0)\n      revert InvalidData();\n  }\n}"
    },
    "lib/wormhole-solidity-sdk/src/constants/Chains.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\n// This file is auto-generated by gen/chains.ts.\n\n// In the wormhole wire format, 0 indicates that a message is for any destination chain\nuint16 constant CHAIN_ID_UNSET = 0;\nuint16 constant CHAIN_ID_SOLANA = 1;\nuint16 constant CHAIN_ID_ETHEREUM = 2;\nuint16 constant CHAIN_ID_TERRA = 3;\nuint16 constant CHAIN_ID_BSC = 4;\nuint16 constant CHAIN_ID_POLYGON = 5;\nuint16 constant CHAIN_ID_AVALANCHE = 6;\nuint16 constant CHAIN_ID_OASIS = 7;\nuint16 constant CHAIN_ID_ALGORAND = 8;\nuint16 constant CHAIN_ID_AURORA = 9;\nuint16 constant CHAIN_ID_FANTOM = 10;\nuint16 constant CHAIN_ID_KARURA = 11;\nuint16 constant CHAIN_ID_ACALA = 12;\nuint16 constant CHAIN_ID_KLAYTN = 13;\nuint16 constant CHAIN_ID_CELO = 14;\nuint16 constant CHAIN_ID_NEAR = 15;\nuint16 constant CHAIN_ID_MOONBEAM = 16;\nuint16 constant CHAIN_ID_NEON = 17;\nuint16 constant CHAIN_ID_TERRA2 = 18;\nuint16 constant CHAIN_ID_INJECTIVE = 19;\nuint16 constant CHAIN_ID_OSMOSIS = 20;\nuint16 constant CHAIN_ID_SUI = 21;\nuint16 constant CHAIN_ID_APTOS = 22;\nuint16 constant CHAIN_ID_ARBITRUM = 23;\nuint16 constant CHAIN_ID_OPTIMISM = 24;\nuint16 constant CHAIN_ID_GNOSIS = 25;\nuint16 constant CHAIN_ID_PYTHNET = 26;\nuint16 constant CHAIN_ID_XPLA = 28;\nuint16 constant CHAIN_ID_BTC = 29;\nuint16 constant CHAIN_ID_BASE = 30;\nuint16 constant CHAIN_ID_SEI = 32;\nuint16 constant CHAIN_ID_SCROLL = 34;\nuint16 constant CHAIN_ID_MANTLE = 35;\nuint16 constant CHAIN_ID_BLAST = 36;\nuint16 constant CHAIN_ID_XLAYER = 37;\nuint16 constant CHAIN_ID_LINEA = 38;\nuint16 constant CHAIN_ID_BERACHAIN = 39;\nuint16 constant CHAIN_ID_SEIEVM = 40;\nuint16 constant CHAIN_ID_SNAXCHAIN = 43;\nuint16 constant CHAIN_ID_UNICHAIN = 44;\nuint16 constant CHAIN_ID_WORLDCHAIN = 45;\nuint16 constant CHAIN_ID_INK = 46;\nuint16 constant CHAIN_ID_HYPER_E_V_M = 47;\nuint16 constant CHAIN_ID_MONAD = 48;\nuint16 constant CHAIN_ID_MEZO = 50;\nuint16 constant CHAIN_ID_WORMCHAIN = 3104;\nuint16 constant CHAIN_ID_COSMOSHUB = 4000;\nuint16 constant CHAIN_ID_EVMOS = 4001;\nuint16 constant CHAIN_ID_KUJIRA = 4002;\nuint16 constant CHAIN_ID_NEUTRON = 4003;\nuint16 constant CHAIN_ID_CELESTIA = 4004;\nuint16 constant CHAIN_ID_STARGAZE = 4005;\nuint16 constant CHAIN_ID_SEDA = 4006;\nuint16 constant CHAIN_ID_DYMENSION = 4007;\nuint16 constant CHAIN_ID_PROVENANCE = 4008;\nuint16 constant CHAIN_ID_NOBLE = 4009;\nuint16 constant CHAIN_ID_SEPOLIA = 10002;\nuint16 constant CHAIN_ID_ARBITRUM_SEPOLIA = 10003;\nuint16 constant CHAIN_ID_BASE_SEPOLIA = 10004;\nuint16 constant CHAIN_ID_OPTIMISM_SEPOLIA = 10005;\nuint16 constant CHAIN_ID_HOLESKY = 10006;\nuint16 constant CHAIN_ID_POLYGON_SEPOLIA = 10007;\n"
    },
    "lib/wormhole-solidity-sdk/src/libraries/PermitParsing.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.14; //for (bugfixed) support of `using ... global;` syntax for libraries\n\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\n\n// ╭─────────────────────────────────────────────────────────────────────────╮\n// │ Library for decoding ERC2612 Permit and Permit2 signatures and metadata │\n// ╰─────────────────────────────────────────────────────────────────────────╯\n\n// # Format\n//\n// ╭─────────┬─────────────┬───────────────────────────────────────────────────╮\n// │  Type   │     Name    │     Description                                   │\n// ┝━━━━━━━━━┷━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │       ERC2612 Permit                                                      │\n// ├─────────┬─────────────┬───────────────────────────────────────────────────┤\n// │ uint256 │ value       │ amount of tokens to approve                       │\n// │ uint256 │ deadline    │ unix timestamp until which the signature is valid │\n// │ bytes32 │ r           │ ECDSA signature component                         │\n// │ bytes32 │ s           │ ECDSA signature component                         │\n// │ uint8   │ v           │ ECDSA signature component                         │\n// ┝━━━━━━━━━┷━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │       Permit2 Permit                                                      │\n// ├─────────┬─────────────┬───────────────────────────────────────────────────┤\n// │ uint160 │ amount      │ amount of tokens to approve                       │\n// │ uint48  │ expiration  │ unix timestamp until which the approval is valid  │\n// │ uint48  │ nonce       │ akin to EVM transaction nonce (must count up)     │\n// │ uint256 │ sigDeadline │ timestamp until which the signature is valid      │\n// │ bytes   │ signature   │ ECDSA signature (r,s,v packed into 65 bytes)      │\n// ┝━━━━━━━━━┷━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │       Permit2 Transfer                                                    │\n// ├─────────┬─────────────┬───────────────────────────────────────────────────┤\n// │ uint256 │ amount      │ amount of tokens to transfer                      │\n// │ uint256 │ nonce       │ akin to EVM transaction nonce (must count up)     │\n// │ uint256 │ sigDeadline │ unix timestamp until which the signature is valid │\n// │ bytes   │ signature   │ ECDSA signature (r,s,v packed into 65 bytes)      │\n// ╰─────────┴─────────────┴───────────────────────────────────────────────────╯\n//\n// # Library Functions & Naming Conventions\n//\n// All decode library functions come in 2x2=4 flavors:\n//   1. Data-Location:\n//     1.1. Calldata (using the Cd tag)\n//     1.2. Memory (using the Mem tag)\n//   2. Return Value:\n//     2.1. individual, stack-based return values (no extra tag)\n//     2.2. the associated, memory-allocated Struct (using the Struct tag)\n//\n// Like in BytesParsing, the Unchecked function name suffix does not refer to\n//   Solidity's `unchecked` keyword, but rather to the fact that no bounds checking\n//   is performed.\n//\n// Decoding functions flavorless base names:\n//   * decodePermit\n//   * decodePermit2Permit\n//   * decodePermit2Transfer\n//\n// Encoding functions (should only be relevant for testing):\n//   * encode (overloaded for each struct)\n//   * encodePermit\n//   * encodePermit2Permit\n//   * encodePermit2Transfer\n\nstruct Permit {\n  uint256 value;\n  uint256 deadline;\n  bytes32 r;\n  bytes32 s;\n  uint8   v;\n}\n\nstruct Permit2Permit {\n  uint160 amount;\n  uint48  expiration;\n  uint48  nonce;\n  uint256 sigDeadline;\n  bytes   signature;\n}\n\nstruct Permit2Transfer {\n  uint256 amount;\n  uint256 nonce;\n  uint256 sigDeadline;\n  bytes   signature;\n}\n\nlibrary PermitParsing {\n  using BytesParsing for bytes;\n  using {BytesParsing.checkLength} for uint;\n\n  error InvalidSignatureLength(uint length);\n\n  uint internal constant SIGNATURE_SIZE = 65;\n  uint internal constant PERMIT_SIZE = 32 + 32 + SIGNATURE_SIZE;\n  uint internal constant PERMIT2_PERMIT_SIZE = 20 + 6 + 6 + 32 + SIGNATURE_SIZE;\n  uint internal constant PERMIT2_TRANSFER_SIZE = 32 + 32 + 32 + SIGNATURE_SIZE;\n\n  // ERC2612 Permit\n\n  function decodePermitCd(\n    bytes calldata params\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v\n  ) {\n    uint offset = 0;\n    (value, deadline, r, s, v, offset) = decodePermitCdUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermitStructCd(\n    bytes calldata params\n  ) internal pure returns (Permit memory permit) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v\n    ) = decodePermitCd(params);\n  }\n\n  function decodePermitCdUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    uint newOffset\n  ) {\n    (value,    offset) = params.asUint256CdUnchecked(offset);\n    (deadline, offset) = params.asUint256CdUnchecked(offset);\n    (r,        offset) = params.asBytes32CdUnchecked(offset);\n    (s,        offset) = params.asBytes32CdUnchecked(offset);\n    (v,        offset) = params.asUint8CdUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function decodePermitCdStructUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (Permit memory permit, uint newOffset) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v,\n      newOffset\n    ) = decodePermitCdUnchecked(params, offset);\n  }\n\n  function decodePermitMem(\n    bytes memory params\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v\n  ) {\n    uint offset = 0;\n    (value, deadline, r, s, v, offset) = decodePermitMemUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermitStructMem(\n    bytes memory params\n  ) internal pure returns (Permit memory permit) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v\n    ) = decodePermitMem(params);\n  }\n\n  function decodePermitMemUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v,\n    uint newOffset\n  ) {\n    (value,    offset) = params.asUint256MemUnchecked(offset);\n    (deadline, offset) = params.asUint256MemUnchecked(offset);\n    (r,        offset) = params.asBytes32MemUnchecked(offset);\n    (s,        offset) = params.asBytes32MemUnchecked(offset);\n    (v,        offset) = params.asUint8MemUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function decodePermitMemStructUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (Permit memory permit, uint newOffset) {\n    ( permit.value,\n      permit.deadline,\n      permit.r,\n      permit.s,\n      permit.v,\n      newOffset\n    ) = decodePermitMemUnchecked(params, offset);\n  }\n\n  // Permit2 Permit\n\n  function decodePermit2PermitCd(\n    bytes calldata params\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes calldata signature\n  ) {\n    uint offset = 0;\n    (amount, expiration, nonce, sigDeadline, signature, offset) =\n      decodePermit2PermitCdUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermit2PermitStructCd(\n    bytes calldata params\n  ) internal pure returns (Permit2Permit memory permit) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature\n    ) = decodePermit2PermitCd(params);\n  }\n\n  function decodePermit2PermitCdUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes calldata signature,\n    uint    newOffset\n  ) {\n    (amount,      offset) = params.asUint160CdUnchecked(offset);\n    (expiration,  offset) = params.asUint48CdUnchecked(offset);\n    (nonce,       offset) = params.asUint48CdUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256CdUnchecked(offset);\n    (signature,   offset) = params.sliceCdUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2PermitCdStructUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (Permit2Permit memory permit, uint newOffset) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature,\n      newOffset\n    ) = decodePermit2PermitCdUnchecked(params, offset);\n  }\n\n  function decodePermit2PermitMem(\n    bytes memory params\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) {\n    uint offset = 0;\n    (amount, expiration, nonce, sigDeadline, signature, offset) =\n      decodePermit2PermitMemUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermit2PermitStructMem(\n    bytes memory params\n  ) internal pure returns (Permit2Permit memory permit) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature\n    ) = decodePermit2PermitMem(params);\n  }\n\n  function decodePermit2PermitMemUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes memory signature,\n    uint    newOffset\n  ) {\n    (amount,      offset) = params.asUint160MemUnchecked(offset);\n    (expiration,  offset) = params.asUint48MemUnchecked(offset);\n    (nonce,       offset) = params.asUint48MemUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256MemUnchecked(offset);\n    (signature,   offset) = params.sliceMemUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2PermitMemStructUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (Permit2Permit memory permit, uint newOffset) {\n    ( permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature,\n      newOffset\n    ) = decodePermit2PermitMemUnchecked(params, offset);\n  }\n\n  // Permit2 Transfer\n\n  function decodePermit2TransferCd(\n    bytes calldata params\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) {\n    uint offset = 0;\n    (amount, nonce, sigDeadline, signature, offset) =\n      decodePermit2TransferCdUnchecked(params, offset);\n    params.length.checkLength(offset);\n  }\n\n  function decodePermit2TransferStructCd(\n    bytes calldata params\n  ) internal pure returns (Permit2Transfer memory transfer) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature\n    ) = decodePermit2TransferCd(params);\n  }\n\n  function decodePermit2TransferCdUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature,\n    uint    newOffset\n  ) {\n    (amount,      offset) = params.asUint256CdUnchecked(offset);\n    (nonce,       offset) = params.asUint256CdUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256CdUnchecked(offset);\n    (signature,   offset) = params.sliceCdUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2TransferCdStructUnchecked(\n    bytes calldata params,\n    uint offset\n  ) internal pure returns (Permit2Transfer memory transfer, uint newOffset) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature,\n      newOffset\n    ) = decodePermit2TransferCdUnchecked(params, offset);\n  }\n\n  function decodePermit2TransferMem(\n    bytes memory params\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) {\n    (amount, nonce, sigDeadline, signature, ) =\n      decodePermit2TransferMemUnchecked(params, 0);\n  }\n\n  function decodePermit2TransferStructMem(\n    bytes memory params\n  ) internal pure returns (Permit2Transfer memory transfer) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature\n    ) = decodePermit2TransferMem(params);\n  }\n\n  function decodePermit2TransferMemUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature,\n    uint newOffset\n  ) {\n    (amount,      offset) = params.asUint256MemUnchecked(offset);\n    (nonce,       offset) = params.asUint256MemUnchecked(offset);\n    (sigDeadline, offset) = params.asUint256MemUnchecked(offset);\n    (signature,   offset) = params.sliceMemUnchecked(offset, SIGNATURE_SIZE);\n    newOffset = offset;\n  }\n\n  function decodePermit2TransferMemStructUnchecked(\n    bytes memory params,\n    uint offset\n  ) internal pure returns (Permit2Transfer memory transfer, uint newOffset) {\n    ( transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature,\n      newOffset\n    ) = decodePermit2TransferMemUnchecked(params, offset);\n  }\n\n  // ------------ Encoding ------------\n\n  function encodePermit(\n    uint256 value,\n    uint256 deadline,\n    bytes32 r,\n    bytes32 s,\n    uint8   v\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(value, deadline, r, s, v);\n  }\n\n  function encode(Permit memory permit) internal pure returns (bytes memory) {\n    return encodePermit(permit.value, permit.deadline, permit.r, permit.s, permit.v);\n  }\n\n  function encodePermit2Permit(\n    uint160 amount,\n    uint48  expiration,\n    uint48  nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) internal pure returns (bytes memory) {\n    if (signature.length != SIGNATURE_SIZE)\n      revert InvalidSignatureLength(signature.length);\n\n    return abi.encodePacked(amount, expiration, nonce, sigDeadline, signature);\n  }\n\n  function encode(Permit2Permit memory permit) internal pure returns (bytes memory) {\n    return encodePermit2Permit(\n      permit.amount,\n      permit.expiration,\n      permit.nonce,\n      permit.sigDeadline,\n      permit.signature\n    );\n  }\n\n  function encodePermit2Transfer(\n    uint256 amount,\n    uint256 nonce,\n    uint256 sigDeadline,\n    bytes memory signature\n  ) internal pure returns (bytes memory) {\n    if (signature.length != SIGNATURE_SIZE)\n      revert InvalidSignatureLength(signature.length);\n\n    return abi.encodePacked(amount, nonce, sigDeadline, signature);\n  }\n\n  function encode(Permit2Transfer memory transfer) internal pure returns (bytes memory) {\n    return encodePermit2Transfer(\n      transfer.amount,\n      transfer.nonce,\n      transfer.sigDeadline,\n      transfer.signature\n    );\n  }\n}\n\nusing PermitParsing for Permit global;\nusing PermitParsing for Permit2Permit global;\nusing PermitParsing for Permit2Transfer global;\n"
    },
    "lib/wormhole-solidity-sdk/src/interfaces/token/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"IERC20/IERC20.sol\";\n\n//https://eips.ethereum.org/EIPS/eip-20\ninterface IERC20Metadata is IERC20 {\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function decimals() external view returns (uint8);\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/interfaces/token/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport \"IERC20/IERC20.sol\";\n\n//https://eips.ethereum.org/EIPS/eip-2612\ninterface IERC20Permit is IERC20 {\n  function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n  function nonces(address owner) external view returns (uint);\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/libraries/VaaLib.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.14; //for (bugfixed) support of `using ... global;` syntax for libraries\n\nimport {IWormhole} from \"wormhole-sdk/interfaces/IWormhole.sol\";\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\nimport {\n  toUniversalAddress,\n  keccak256Cd,\n  keccak256Word,\n  keccak256SliceUnchecked\n} from \"wormhole-sdk/Utils.sol\";\n\n// ╭─────────────────────────────────────────────────╮\n// │ Library for encoding and decoding Wormhole VAAs │\n// ╰─────────────────────────────────────────────────╯\n\n// # VAA Format\n//\n// see:\n//  * ../interfaces/IWormhole.sol VM struct (VM = Verified Message)\n//  * [CoreBridge](https://github.com/wormhole-foundation/wormhole/blob/c35940ae9689f6df9e983d51425763509b74a80f/ethereum/contracts/Messages.sol#L147)\n//  * [Typescript SDK](https://github.com/wormhole-foundation/wormhole-sdk-ts/blob/3cd10030b5e924f0621c7231e24410b8a0946a07/core/definitions/src/vaa/vaa.ts#L32-L51)\n//\n// ╭──────────┬──────────────────────────────────────────────────────────────────────────────╮\n// │ Section  │ Description                                                                  │\n// ├──────────┼──────────────────────────────────────────────────────────────────────────────┤\n// │ Header   │ version, guardian signature info required to verify the VAA                  │\n// │ Envelope │ contains metadata of the emitted message, such as emitter or timestamp       │\n// │ Payload  │ the emitted message, raw bytes, no length prefix, consumes remainder of data │\n// ╰──────────┴──────────────────────────────────────────────────────────────────────────────╯\n// Body = Envelope + Payload\n// The VAA body is exactly the information that goes into a published message of the CoreBridge\n//   and is what gets keccak256-hashed when calculating the VAA hash (i.e. the header is excluded).\n//\n// Note:\n//   Guardians do _not_ sign the body directly, but rather the hash of the body, i.e. from the PoV\n//     of a guardian, the message itself is already only a hash.\n//   But [the first step of the ECDSA signature scheme](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_generation_algorithm)\n//     is to hash the message, leading to the hash being hashed a second time when signing.\n//   Likewise, ecrecover also operates on the hash of the message, rather than the message itself.\n//   This means that when verifying guardian signatures of a VAA, the hash that must be passed to\n//     ecrecover is the doubly-hashed body.\n//\n// ╭─────────────────────────────────────── WARNING ───────────────────────────────────────╮\n// │ There is an unfortunate inconsistency between the implementation of the CoreBridge on │\n// │   EVM, where IWormhole.VM.hash is the *doubly* hashed body [1], while everything else │\n// │   only uses the singly-hashed body (see Solana CoreBridge [2] and Typescript SDK [3]) │\n// ╰───────────────────────────────────────────────────────────────────────────────────────╯\n// [1] https://github.com/wormhole-foundation/wormhole/blob/1dbe8459b96e182932d0dd5ae4b6bbce6f48cb09/ethereum/contracts/Messages.sol#L178-L186\n// [2] https://github.com/wormhole-foundation/wormhole/blob/1dbe8459b96e182932d0dd5ae4b6bbce6f48cb09/solana/bridge/program/src/api/post_vaa.rs#L214C4-L244\n// [3] https://github.com/wormhole-foundation/wormhole-sdk-ts/blob/3cd10030b5e924f0621c7231e24410b8a0946a07/core/definitions/src/vaa/functions.ts#L189\n//\n// ## Format in Detail\n//\n// ╭─────────────┬──────────────────┬──────────────────────────────────────────────────────────────╮\n// │    Type     │       Name       │     Description                                              │\n// ┝━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │           Header                                                                              │\n// ├─────────────┬──────────────────┬──────────────────────────────────────────────────────────────┤\n// │    uint8    │ version          │ fixed value of 1 (see HEADER_VERSION below)                  │\n// │    uint32   │ guardianSetIndex │ the guardian set that signed the VAA                         │\n// │    uint8    │ signatureCount   │ must be greater than guardian set size * 2 / 3 for quorum    │\n// │ Signature[] │ signatures       │ signatures of the guardians that signed the VAA              │\n// ┝━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │          Signature                                                                            │\n// ├─────────────┬──────────────────┬──────────────────────────────────────────────────────────────┤\n// │    uint8    │ guardianIndex    │ position of the signing guardian in the guardian set         │\n// │   bytes32   │ r                │ ECDSA r value                                                │\n// │   bytes32   │ s                │ ECDSA s value                                                │\n// │    uint8    │ v                │ encoded: 0/1, decoded: 27/28, see SIGNATURE_RECOVERY_MAGIC   │\n// ┝━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │          Envelope                                                                             │\n// ├─────────────┬──────────────────┬──────────────────────────────────────────────────────────────┤\n// │    uint32   │ timestamp        │ unix timestamp of block containing the emitted message       │\n// │    uint32   │ nonce            │ user-defined nonce                                           │\n// │    uint16   │ emitterChainId   │ Wormhole (not EVM) chain id of the emitter                   │\n// │   bytes32   │ emitterAddress   │ universal address of the emitter                             │\n// │    uint64   │ sequence         │ sequence number of the message (counter per emitter)         │\n// │    uint8    │ consistencyLevel │ https://wormhole.com/docs/build/reference/consistency-levels │\n// ┝━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │          Payload                                                                              │\n// ├─────────────┬──────────────────┬──────────────────────────────────────────────────────────────┤\n// │    bytes    │ payload          │ emitted message, consumes rest of VAA (no length prefix)     │\n// ╰─────────────┴──────────────────┴──────────────────────────────────────────────────────────────╯\n//\n// # Library\n//\n// This library is built on top of BytesParsing which is a lot more gas efficient than BytesLib,\n//   which is used in the CoreBridge.\n//\n// It also provides decoding functions for parsing the individual components of the VAA separately\n//   and returning them on the stack, rather than as a struct which requires memory allocation.\n//\n// ## Library Functions & Naming Conventions\n//\n// All library functions come in 2 flavors:\n//   1. Calldata (using the Cd tag)\n//   2. Memory (using the Mem tag)\n//\n// Additionally, most functions also have an additional struct flavor that returns the decoded\n//   values in the associated struct (in memory), rather than as individual values (on the stack).\n//\n// The parameter name `encodedVaa` is used for functions where the bytes are expected to contain\n//   a single, full VAA. Otherwise, i.e. for partials or multiple VAAs, the name `encoded` is used.\n//\n// Like in BytesParsing, the Unchecked function name suffix does not refer to Solidity's `unchecked`\n//   keyword, but rather to the fact that no bounds checking is performed. All math is done using\n//   unchecked arithmetic because overflows are impossible due to the nature of the VAA format,\n//   while we explicitly check for underflows where necessary.\n//\n// Function names, somewhat redundantly, contain the tag \"Vaa\" to add clarity and avoid potential\n//   name collisions when using the library with a `using ... for bytes` directive.\n//\n//   Function Base Name  │     Description\n//  ─────────────────────┼────────────────────────────────────────────────────────────────────────\n//   decodeVmStruct      │ decodes a legacy VM struct (no non-struct flavor available)\n//   decodeVaaEssentials │ decodes the emitter, sequence, and payload\n//   decodeVaaBody       │ decodes the envelope and payload\n//   checkVaaVersion     │\n//   skipVaaHeader       │ returns the offset to the envelope\n//   calcVaaSingleHash   │ see explanation/WARNING box at the top\n//   calcVaaDoubleHash   │ see explanation/WARNING box at the top\n//   decodeVaaEnvelope   │\n//   decodeVaaPayload    │\n//\n// encode functions (for testing, converts back into serialized byte array format):\n//   * encode (overloaded for each struct)\n//   * encodeVaaHeader\n//   * encodeVaaEnvelope\n//   * encodeVaaBody\n//   * encodeVaa\n//\n// other functions:\n//   * asIWormholeSignatures (casting between GuardianSignature and IWormhole.Signature)\n//   * asGuardianSignatures (casting between GuardianSignature and IWormhole.Signature)\n\n//Annoyingly, Solidity only allows aliasing of types that are exported on the file level, but not\n//  of nested types, see [language grammar](https://docs.soliditylang.org/en/v0.8.28/grammar.html#a4.SolidityParser.importDirective)\n//So we (re)define GuardianSignature identically to IWormhole.Signature to avoid the explicit\n//  dependency and to provide a better name and do the necessary casts manually using assembly.\n//Without the alias, users who want to reference the GuardianSignature type would have to import\n//  IWormhole themselves, which breaks the intended encapsulation of this library.\nstruct GuardianSignature {\n  bytes32 r;\n  bytes32 s;\n  uint8 v;\n  uint8 guardianIndex;\n}\n\nstruct VaaHeader {\n  //uint8 version;\n  uint32 guardianSetIndex;\n  GuardianSignature[] signatures;\n}\n\nstruct VaaEnvelope {\n  uint32 timestamp;\n  uint32 nonce;\n  uint16 emitterChainId;\n  bytes32 emitterAddress;\n  uint64 sequence;\n  uint8 consistencyLevel;\n}\n\nstruct VaaBody {\n  VaaEnvelope envelope;\n  bytes payload;\n}\n\nstruct Vaa {\n  VaaHeader header;\n  VaaEnvelope envelope;\n  bytes payload;\n}\n\nstruct VaaEssentials {\n  uint16 emitterChainId;\n  bytes32 emitterAddress;\n  uint64 sequence;\n  bytes payload;\n}\n\nlibrary VaaLib {\n  using BytesParsing for bytes;\n  using {BytesParsing.checkBound} for uint;\n\n  error InvalidVersion(uint8 version);\n\n  uint8 internal constant HEADER_VERSION = 1;\n  //see https://github.com/wormhole-foundation/wormhole/blob/c35940ae9689f6df9e983d51425763509b74a80f/ethereum/contracts/Messages.sol#L174\n  //origin: https://bitcoin.stackexchange.com/a/102382\n  uint8 internal constant SIGNATURE_RECOVERY_MAGIC = 27;\n\n  //the following offsets are provided for more eclectic, manual parsing\n  uint internal constant HEADER_VERSION_OFFSET = 0;\n  uint internal constant HEADER_VERSION_SIZE = 1;\n\n  uint internal constant HEADER_GUARDIAN_SET_INDEX_OFFSET =\n    HEADER_VERSION_OFFSET + HEADER_VERSION_SIZE;\n  uint internal constant HEADER_GUARDIAN_SET_INDEX_SIZE = 4;\n\n  uint internal constant HEADER_SIGNATURE_COUNT_OFFSET =\n    HEADER_GUARDIAN_SET_INDEX_OFFSET + HEADER_GUARDIAN_SET_INDEX_SIZE;\n  uint internal constant HEADER_SIGNATURE_COUNT_SIZE = 1;\n\n  uint internal constant HEADER_SIGNATURE_ARRAY_OFFSET =\n    HEADER_SIGNATURE_COUNT_OFFSET + HEADER_SIGNATURE_COUNT_SIZE;\n\n  uint internal constant GUARDIAN_SIGNATURE_GUARDIAN_INDEX_OFFSET = 0;\n  uint internal constant GUARDIAN_SIGNATURE_GUARDIAN_INDEX_SIZE = 1;\n\n  uint internal constant GUARDIAN_SIGNATURE_R_OFFSET =\n    GUARDIAN_SIGNATURE_GUARDIAN_INDEX_OFFSET + GUARDIAN_SIGNATURE_GUARDIAN_INDEX_SIZE;\n  uint internal constant GUARDIAN_SIGNATURE_R_SIZE = 32;\n\n  uint internal constant GUARDIAN_SIGNATURE_S_OFFSET =\n    GUARDIAN_SIGNATURE_R_OFFSET + GUARDIAN_SIGNATURE_R_SIZE;\n  uint internal constant GUARDIAN_SIGNATURE_S_SIZE = 32;\n\n  uint internal constant GUARDIAN_SIGNATURE_V_OFFSET =\n    GUARDIAN_SIGNATURE_S_OFFSET + GUARDIAN_SIGNATURE_S_SIZE;\n  uint internal constant GUARDIAN_SIGNATURE_V_SIZE = 1;\n\n  uint internal constant GUARDIAN_SIGNATURE_SIZE =\n    GUARDIAN_SIGNATURE_V_OFFSET + GUARDIAN_SIGNATURE_V_SIZE;\n\n  uint internal constant ENVELOPE_TIMESTAMP_OFFSET = 0;\n  uint internal constant ENVELOPE_TIMESTAMP_SIZE = 4;\n\n  uint internal constant ENVELOPE_NONCE_OFFSET =\n    ENVELOPE_TIMESTAMP_OFFSET + ENVELOPE_TIMESTAMP_SIZE;\n  uint internal constant ENVELOPE_NONCE_SIZE = 4;\n\n  uint internal constant ENVELOPE_EMITTER_CHAIN_ID_OFFSET =\n    ENVELOPE_NONCE_OFFSET + ENVELOPE_NONCE_SIZE;\n  uint internal constant ENVELOPE_EMITTER_CHAIN_ID_SIZE = 2;\n\n  uint internal constant ENVELOPE_EMITTER_ADDRESS_OFFSET =\n    ENVELOPE_EMITTER_CHAIN_ID_OFFSET + ENVELOPE_EMITTER_CHAIN_ID_SIZE;\n  uint internal constant ENVELOPE_EMITTER_ADDRESS_SIZE = 32;\n\n  uint internal constant ENVELOPE_SEQUENCE_OFFSET =\n    ENVELOPE_EMITTER_ADDRESS_OFFSET + ENVELOPE_EMITTER_ADDRESS_SIZE;\n  uint internal constant ENVELOPE_SEQUENCE_SIZE = 8;\n\n  uint internal constant ENVELOPE_CONSISTENCY_LEVEL_OFFSET =\n    ENVELOPE_SEQUENCE_OFFSET + ENVELOPE_SEQUENCE_SIZE;\n  uint internal constant ENVELOPE_CONSISTENCY_LEVEL_SIZE = 1;\n\n  uint internal constant ENVELOPE_SIZE =\n    ENVELOPE_CONSISTENCY_LEVEL_OFFSET + ENVELOPE_CONSISTENCY_LEVEL_SIZE;\n\n  // ------------ Convenience Decoding Functions ------------\n\n  //legacy decoder for IWormhole.VM\n  function decodeVmStructCd(\n    bytes calldata encodedVaa\n  ) internal pure returns (IWormhole.VM memory vm) {\n    vm.version = HEADER_VERSION;\n    uint envelopeOffset;\n    GuardianSignature[] memory signatures;\n    (vm.guardianSetIndex, signatures, envelopeOffset) = decodeVaaHeaderCdUnchecked(encodedVaa);\n    vm.signatures = asIWormholeSignatures(signatures);\n    vm.hash = calcVaaDoubleHashCd(encodedVaa, envelopeOffset);\n    ( vm.timestamp,\n      vm.nonce,\n      vm.emitterChainId,\n      vm.emitterAddress,\n      vm.sequence,\n      vm.consistencyLevel,\n      vm.payload\n    ) = decodeVaaBodyCd(encodedVaa, envelopeOffset);\n  }\n\n  function decodeVmStructMem(\n    bytes memory encodedVaa\n  ) internal pure returns (IWormhole.VM memory vm) {\n    (vm, ) = decodeVmStructMemUnchecked(encodedVaa, 0, encodedVaa.length);\n  }\n\n  function decodeVaaStructCd(\n    bytes calldata encodedVaa\n  ) internal pure returns (Vaa memory vaa) {\n    uint envelopeOffset;\n    (vaa.header, envelopeOffset) = decodeVaaHeaderStructCdUnchecked(encodedVaa);\n\n    uint payloadOffset;\n    (vaa.envelope, payloadOffset) = decodeVaaEnvelopeStructCdUnchecked(encodedVaa, envelopeOffset);\n    vaa.payload = decodeVaaPayloadCd(encodedVaa, payloadOffset);\n  }\n\n  function decodeVaaStructMem(\n    bytes memory encodedVaa\n  ) internal pure returns (Vaa memory vaa) {\n    (vaa, ) = decodeVaaStructMemUnchecked(encodedVaa, 0, encodedVaa.length);\n  }\n\n  function decodeVaaEssentialsCd(\n    bytes calldata encodedVaa\n  ) internal pure returns (\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    bytes calldata payload\n  ) { unchecked {\n    checkVaaVersionCd(encodedVaa);\n\n    uint envelopeOffset = skipVaaHeaderCd(encodedVaa);\n    uint offset = envelopeOffset + ENVELOPE_EMITTER_CHAIN_ID_OFFSET;\n    (emitterChainId, offset) = encodedVaa.asUint16CdUnchecked(offset);\n    (emitterAddress, offset) = encodedVaa.asBytes32CdUnchecked(offset);\n    (sequence,             ) = encodedVaa.asUint64CdUnchecked(offset);\n\n    uint payloadOffset = envelopeOffset + ENVELOPE_SIZE;\n    payload = decodeVaaPayloadCd(encodedVaa, payloadOffset);\n  }}\n\n  function decodeVaaEssentialsStructCd(\n    bytes calldata encodedVaa\n  ) internal pure returns (VaaEssentials memory ret) {\n    (ret.emitterChainId, ret.emitterAddress, ret.sequence, ret.payload) =\n      decodeVaaEssentialsCd(encodedVaa);\n  }\n\n  //The returned values are considered the essentials because it's important to check the emitter\n  //  to avoid spoofing. Also, VAAs that use finalized consistency levels should leverage the\n  //  sequence number (on a per emitter basis!) and a bitmap for replay protection rather than the\n  //  hashed body because it is more gas efficient (storage slot is likely already dirty).\n  function decodeVaaEssentialsMem(\n    bytes memory encodedVaa\n  ) internal pure returns (\n    uint16 emitterChainId,\n    bytes32 emitterAddress,\n    uint64 sequence,\n    bytes memory payload\n  ) {\n    (emitterChainId, emitterAddress, sequence, payload, ) =\n      decodeVaaEssentialsMem(encodedVaa, 0, encodedVaa.length);\n  }\n\n  function decodeVaaEssentialsStructMem(\n    bytes memory encodedVaa\n  ) internal pure returns (VaaEssentials memory ret) {\n    (ret.emitterChainId, ret.emitterAddress, ret.sequence, ret.payload, ) =\n      decodeVaaEssentialsMem(encodedVaa, 0, encodedVaa.length);\n  }\n\n  function decodeVaaEssentialsMem(\n    bytes memory encoded,\n    uint headerOffset,\n    uint vaaLength\n  ) internal pure returns (\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    bytes memory payload,\n    uint    newOffset\n  ) { unchecked {\n    uint offset = checkVaaVersionMemUnchecked(encoded, headerOffset);\n\n    uint envelopeOffset = skipVaaHeaderMemUnchecked(encoded, offset);\n    offset = envelopeOffset + ENVELOPE_EMITTER_CHAIN_ID_OFFSET;\n    (emitterChainId, offset) = encoded.asUint16MemUnchecked(offset);\n    (emitterAddress, offset) = encoded.asBytes32MemUnchecked(offset);\n    (sequence,             ) = encoded.asUint64MemUnchecked(offset);\n\n    uint payloadOffset = envelopeOffset + ENVELOPE_SIZE;\n    (payload, newOffset) = decodeVaaPayloadMemUnchecked(encoded, payloadOffset, vaaLength);\n  }}\n\n  function decodeVaaEssentialsStructMem(\n    bytes memory encodedVaa,\n    uint headerOffset,\n    uint vaaLength\n  ) internal pure returns (VaaEssentials memory ret, uint newOffset) {\n    (ret.emitterChainId, ret.emitterAddress, ret.sequence, ret.payload, newOffset) =\n      decodeVaaEssentialsMem(encodedVaa, headerOffset, vaaLength);\n  }\n\n  function decodeVaaBodyCd(\n    bytes calldata encodedVaa\n  ) internal pure returns (\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    bytes calldata payload\n  ) {\n    checkVaaVersionCd(encodedVaa);\n    (timestamp, nonce, emitterChainId, emitterAddress, sequence, consistencyLevel, payload) =\n      decodeVaaBodyCd(encodedVaa, skipVaaHeaderCd(encodedVaa));\n  }\n\n  function decodeVaaBodyStructCd(\n    bytes calldata encodedVaa\n  ) internal pure returns (VaaBody memory body) {\n    ( body.envelope.timestamp,\n      body.envelope.nonce,\n      body.envelope.emitterChainId,\n      body.envelope.emitterAddress,\n      body.envelope.sequence,\n      body.envelope.consistencyLevel,\n      body.payload\n    ) = decodeVaaBodyCd(encodedVaa);\n  }\n\n  function decodeVaaBodyMem(\n    bytes memory encodedVaa\n  ) internal pure returns (\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    bytes memory payload\n  ) {\n    checkVaaVersionMemUnchecked(encodedVaa, 0);\n    uint envelopeOffset = skipVaaHeaderMemUnchecked(encodedVaa, 0);\n    (timestamp, nonce, emitterChainId, emitterAddress, sequence, consistencyLevel, payload, ) =\n      decodeVaaBodyMemUnchecked(encodedVaa, envelopeOffset, encodedVaa.length);\n  }\n\n  function decodeVaaBodyStructMem(\n    bytes memory encodedVaa\n  ) internal pure returns (VaaBody memory body) {\n    ( body.envelope.timestamp,\n      body.envelope.nonce,\n      body.envelope.emitterChainId,\n      body.envelope.emitterAddress,\n      body.envelope.sequence,\n      body.envelope.consistencyLevel,\n      body.payload,\n    ) = decodeVaaBodyMemUnchecked(encodedVaa, 0, encodedVaa.length);\n  }\n\n  // Convinience decoding function for token bridge Vaas\n  function decodeEmitterChainAndPayloadCdUnchecked(\n    bytes calldata encodedVaa\n  ) internal pure returns (uint16 emitterChainId, bytes calldata payload) { unchecked {\n    checkVaaVersionCd(encodedVaa);\n    uint envelopeOffset = skipVaaHeaderCd(encodedVaa);\n    uint offset = envelopeOffset + ENVELOPE_EMITTER_CHAIN_ID_OFFSET;\n    (emitterChainId, offset) = encodedVaa.asUint16CdUnchecked(offset);\n    offset += ENVELOPE_EMITTER_ADDRESS_SIZE + ENVELOPE_SEQUENCE_SIZE + ENVELOPE_CONSISTENCY_LEVEL_SIZE;\n    payload = decodeVaaPayloadCd(encodedVaa, offset);\n  }}\n\n  function decodeEmitterChainAndPayloadMemUnchecked(\n    bytes memory encodedVaa\n  ) internal pure returns (uint16 emitterChainId, bytes memory payload) { unchecked {\n    checkVaaVersionMemUnchecked(encodedVaa, 0);\n    uint envelopeOffset = skipVaaHeaderMemUnchecked(encodedVaa, 0);\n    uint offset = envelopeOffset + ENVELOPE_EMITTER_CHAIN_ID_OFFSET;\n    (emitterChainId, offset) = encodedVaa.asUint16MemUnchecked(offset);\n    offset += ENVELOPE_EMITTER_ADDRESS_SIZE + ENVELOPE_SEQUENCE_SIZE + ENVELOPE_CONSISTENCY_LEVEL_SIZE;\n    (payload, ) = decodeVaaPayloadMemUnchecked(encodedVaa, offset, encodedVaa.length);\n  }}\n\n  // ------------ Advanced Decoding Functions ------------\n\n  function asIWormholeSignatures(\n    GuardianSignature[] memory signatures\n  ) internal pure returns (IWormhole.Signature[] memory vmSignatures) {\n    assembly (\"memory-safe\") {\n      vmSignatures := signatures\n    }\n  }\n\n  function asGuardianSignatures(\n    IWormhole.Signature[] memory vmSignatures\n  ) internal pure returns (GuardianSignature[] memory signatures) {\n    assembly (\"memory-safe\") {\n      signatures := vmSignatures\n    }\n  }\n\n  function checkVaaVersionCd(bytes calldata encodedVaa) internal pure returns (uint newOffset) {\n    uint8 version;\n    (version, newOffset) = encodedVaa.asUint8CdUnchecked(0);\n    checkVaaVersion(version);\n  }\n\n  function checkVaaVersionMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (uint newOffset) {\n    uint8 version;\n    (version, newOffset) = encoded.asUint8MemUnchecked(offset);\n    checkVaaVersion(version);\n  }\n\n  function checkVaaVersion(uint8 version) internal pure {\n    if (version != HEADER_VERSION)\n      revert InvalidVersion(version);\n  }\n\n  //return the offset to the start of the envelope/body\n  function skipVaaHeaderCd(\n    bytes calldata encodedVaa\n  ) internal pure returns (uint envelopeOffset) { unchecked {\n    (uint sigCount, uint offset) = encodedVaa.asUint8CdUnchecked(HEADER_SIGNATURE_COUNT_OFFSET);\n    envelopeOffset = offset + sigCount * GUARDIAN_SIGNATURE_SIZE;\n  }}\n\n  function skipVaaHeaderMemUnchecked(\n    bytes memory encoded,\n    uint headerOffset\n  ) internal pure returns (uint envelopeOffset) { unchecked {\n    uint offset = headerOffset + HEADER_SIGNATURE_COUNT_OFFSET;\n    uint sigCount;\n    (sigCount, offset) = encoded.asUint8MemUnchecked(offset);\n    envelopeOffset = offset + sigCount * GUARDIAN_SIGNATURE_SIZE;\n  }}\n\n  //see WARNING box at the top\n  function calcVaaSingleHashCd(\n    bytes calldata encodedVaa,\n    uint envelopeOffset\n  ) internal pure returns (bytes32) {\n    return keccak256Cd(_decodeRemainderCd(encodedVaa, envelopeOffset));\n  }\n\n  //see WARNING box at the top\n  function calcVaaSingleHashMem(\n    bytes memory encoded,\n    uint envelopeOffset,\n    uint vaaLength\n  ) internal pure returns (bytes32) { unchecked {\n    envelopeOffset.checkBound(vaaLength);\n    return keccak256SliceUnchecked(encoded, envelopeOffset, vaaLength - envelopeOffset);\n  }}\n\n  //see WARNING box at the top\n  function calcSingleHash(Vaa memory vaa) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(encode(vaa.envelope), vaa.payload));\n  }\n\n  //see WARNING box at the top\n  function calcSingleHash(VaaBody memory body) internal pure returns (bytes32) {\n    return keccak256(encode(body));\n  }\n\n  //see WARNING box at the top\n  //this function matches IWormhole.VM.hash and is what's been used for (legacy) replay protection\n  function calcVaaDoubleHashCd(\n    bytes calldata encodedVaa,\n    uint envelopeOffset\n  ) internal pure returns (bytes32) {\n    return keccak256Word(calcVaaSingleHashCd(encodedVaa, envelopeOffset));\n  }\n\n  //see WARNING box at the top\n  function calcVaaDoubleHashMem(\n    bytes memory encoded,\n    uint envelopeOffset,\n    uint vaaLength\n  ) internal pure returns (bytes32) {\n    return keccak256Word(calcVaaSingleHashMem(encoded, envelopeOffset, vaaLength));\n  }\n\n  //see WARNING box at the top\n  function calcDoubleHash(Vaa memory vaa) internal pure returns (bytes32) {\n    return keccak256Word(calcSingleHash(vaa));\n  }\n\n  //see WARNING box at the top\n  function calcDoubleHash(VaaBody memory body) internal pure returns (bytes32) {\n    return keccak256Word(calcSingleHash(body));\n  }\n\n  function decodeVmStructMemUnchecked(\n    bytes memory encoded,\n    uint headerOffset,\n    uint vaaLength\n  ) internal pure returns (IWormhole.VM memory vm, uint newOffset) {\n    vm.version = HEADER_VERSION;\n    uint envelopeOffset;\n    GuardianSignature[] memory signatures;\n    (vm.guardianSetIndex, signatures, envelopeOffset) =\n      decodeVaaHeaderMemUnchecked(encoded, headerOffset);\n    vm.signatures = asIWormholeSignatures(signatures);\n    vm.hash = calcVaaDoubleHashMem(encoded, envelopeOffset, vaaLength);\n    ( vm.timestamp,\n      vm.nonce,\n      vm.emitterChainId,\n      vm.emitterAddress,\n      vm.sequence,\n      vm.consistencyLevel,\n      vm.payload,\n      newOffset\n    ) = decodeVaaBodyMemUnchecked(encoded, envelopeOffset, vaaLength);\n  }\n\n  function decodeVaaStructMemUnchecked(\n    bytes memory encoded,\n    uint headerOffset,\n    uint vaaLength\n  ) internal pure returns (Vaa memory vaa, uint newOffset) {\n    uint envelopeOffset;\n    (vaa.header.guardianSetIndex, vaa.header.signatures, envelopeOffset) =\n      decodeVaaHeaderMemUnchecked(encoded, headerOffset);\n\n    uint payloadOffset;\n    (vaa.envelope, payloadOffset) = decodeVaaEnvelopeStructMemUnchecked(encoded, envelopeOffset);\n\n    (vaa.payload, newOffset) = decodeVaaPayloadMemUnchecked(encoded, payloadOffset, vaaLength);\n  }\n\n  function decodeVaaBodyCd(\n    bytes calldata encodedVaa,\n    uint envelopeOffset\n  ) internal pure returns (\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    bytes calldata payload\n  ) {\n    uint payloadOffset;\n    (timestamp, nonce, emitterChainId, emitterAddress, sequence, consistencyLevel, payloadOffset) =\n      decodeVaaEnvelopeCdUnchecked(encodedVaa, envelopeOffset);\n    payload = decodeVaaPayloadCd(encodedVaa, payloadOffset);\n  }\n\n  function decodeVaaBodyStructCd(\n    bytes calldata encodedVaa,\n    uint envelopeOffset\n  ) internal pure returns (VaaBody memory body) {\n    ( body.envelope.timestamp,\n      body.envelope.nonce,\n      body.envelope.emitterChainId,\n      body.envelope.emitterAddress,\n      body.envelope.sequence,\n      body.envelope.consistencyLevel,\n      body.payload\n    ) = decodeVaaBodyCd(encodedVaa, envelopeOffset);\n  }\n\n  function decodeVaaBodyMemUnchecked(\n    bytes memory encoded,\n    uint envelopeOffset,\n    uint vaaLength\n  ) internal pure returns (\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    bytes memory payload,\n    uint    newOffset\n  ) {\n    uint payloadOffset;\n    (timestamp, nonce, emitterChainId, emitterAddress, sequence, consistencyLevel, payloadOffset) =\n      decodeVaaEnvelopeMemUnchecked(encoded, envelopeOffset);\n    (payload, newOffset) = decodeVaaPayloadMemUnchecked(encoded, payloadOffset, vaaLength);\n  }\n\n  function decodeVaaBodyStructMemUnchecked(\n    bytes memory encoded,\n    uint envelopeOffset,\n    uint vaaLength\n  ) internal pure returns (VaaBody memory body, uint newOffset) {\n    ( body.envelope.timestamp,\n      body.envelope.nonce,\n      body.envelope.emitterChainId,\n      body.envelope.emitterAddress,\n      body.envelope.sequence,\n      body.envelope.consistencyLevel,\n      body.payload,\n      newOffset\n    ) = decodeVaaBodyMemUnchecked(encoded, envelopeOffset, vaaLength);\n  }\n\n  function decodeVaaEnvelopeCdUnchecked(\n    bytes calldata encodedVaa,\n    uint envelopeOffset\n  ) internal pure returns (\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    uint    payloadOffset\n  ) {\n    uint offset = envelopeOffset;\n    (timestamp,        offset) = encodedVaa.asUint32CdUnchecked(offset);\n    (nonce,            offset) = encodedVaa.asUint32CdUnchecked(offset);\n    (emitterChainId,   offset) = encodedVaa.asUint16CdUnchecked(offset);\n    (emitterAddress,   offset) = encodedVaa.asBytes32CdUnchecked(offset);\n    (sequence,         offset) = encodedVaa.asUint64CdUnchecked(offset);\n    (consistencyLevel, offset) = encodedVaa.asUint8CdUnchecked(offset);\n    payloadOffset = offset;\n  }\n\n  function decodeVaaEnvelopeStructCdUnchecked(\n    bytes calldata encodedVaa,\n    uint envelopeOffset\n  ) internal pure returns (VaaEnvelope memory envelope, uint payloadOffset) {\n    ( envelope.timestamp,\n      envelope.nonce,\n      envelope.emitterChainId,\n      envelope.emitterAddress,\n      envelope.sequence,\n      envelope.consistencyLevel,\n      payloadOffset\n    ) = decodeVaaEnvelopeCdUnchecked(encodedVaa, envelopeOffset);\n  }\n\n  function decodeVaaEnvelopeMemUnchecked(\n    bytes memory encoded,\n    uint envelopeOffset\n  ) internal pure returns (\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    uint    payloadOffset\n  ) {\n    uint offset = envelopeOffset;\n    (timestamp,        offset) = encoded.asUint32MemUnchecked(offset);\n    (nonce,            offset) = encoded.asUint32MemUnchecked(offset);\n    (emitterChainId,   offset) = encoded.asUint16MemUnchecked(offset);\n    (emitterAddress,   offset) = encoded.asBytes32MemUnchecked(offset);\n    (sequence,         offset) = encoded.asUint64MemUnchecked(offset);\n    (consistencyLevel, offset) = encoded.asUint8MemUnchecked(offset);\n    payloadOffset = offset;\n  }\n\n  function decodeVaaEnvelopeStructMemUnchecked(\n    bytes memory encoded,\n    uint envelopeOffset\n  ) internal pure returns (VaaEnvelope memory envelope, uint payloadOffset) {\n    ( envelope.timestamp,\n      envelope.nonce,\n      envelope.emitterChainId,\n      envelope.emitterAddress,\n      envelope.sequence,\n      envelope.consistencyLevel,\n      payloadOffset\n    ) = decodeVaaEnvelopeMemUnchecked(encoded, envelopeOffset);\n  }\n\n  function decodeVaaHeaderCdUnchecked(\n    bytes calldata encodedVaa\n  ) internal pure returns (\n    uint32 guardianSetIndex,\n    GuardianSignature[] memory signatures,\n    uint envelopeOffset\n  ) { unchecked {\n    checkVaaVersionCd(encodedVaa);\n    uint offset = HEADER_GUARDIAN_SET_INDEX_OFFSET;\n    (guardianSetIndex, offset) = encodedVaa.asUint32CdUnchecked(offset);\n\n    uint signersLen;\n    (signersLen, offset) = encodedVaa.asUint8CdUnchecked(offset);\n\n    signatures = new GuardianSignature[](signersLen);\n    for (uint i = 0; i < signersLen; ++i)\n      (signatures[i], offset) = decodeGuardianSignatureStructCdUnchecked(encodedVaa, offset);\n\n    envelopeOffset = offset;\n  }}\n\n  function decodeVaaHeaderStructCdUnchecked(\n    bytes calldata encodedVaa\n  ) internal pure returns (VaaHeader memory header, uint envelopeOffset) {\n    ( header.guardianSetIndex,\n      header.signatures,\n      envelopeOffset\n    ) = decodeVaaHeaderCdUnchecked(encodedVaa);\n  }\n\n  function decodeVaaHeaderMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (\n    uint32 guardianSetIndex,\n    GuardianSignature[] memory signatures,\n    uint envelopeOffset\n  ) { unchecked {\n    offset = checkVaaVersionMemUnchecked(encoded, offset);\n    (guardianSetIndex, offset) = encoded.asUint32MemUnchecked(offset);\n\n    uint signersLen;\n    (signersLen, offset) = encoded.asUint8MemUnchecked(offset);\n\n    signatures = new GuardianSignature[](signersLen);\n    for (uint i = 0; i < signersLen; ++i)\n      (signatures[i], offset) = decodeGuardianSignatureStructMemUnchecked(encoded, offset);\n\n    envelopeOffset = offset;\n  }}\n\n  function decodeVaaHeaderStructMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (VaaHeader memory header, uint envelopeOffset) {\n    ( header.guardianSetIndex,\n      header.signatures,\n      envelopeOffset\n    ) = decodeVaaHeaderMemUnchecked(encoded, offset);\n  }\n\n  function decodeGuardianSignatureCdUnchecked(\n    bytes calldata encodedVaa,\n    uint offset\n  ) internal pure returns (\n    uint8 guardianIndex,\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    uint newOffset\n  ) { unchecked {\n    (guardianIndex, offset) = encodedVaa.asUint8CdUnchecked(offset);\n    (r,             offset) = encodedVaa.asBytes32CdUnchecked(offset);\n    (s,             offset) = encodedVaa.asBytes32CdUnchecked(offset);\n    (v,             offset) = encodedVaa.asUint8CdUnchecked(offset);\n    v += SIGNATURE_RECOVERY_MAGIC;\n    newOffset = offset;\n  }}\n\n  function decodeGuardianSignatureStructCdUnchecked(\n    bytes calldata encodedVaa,\n    uint offset\n  ) internal pure returns (GuardianSignature memory ret, uint newOffset) {\n    (ret.guardianIndex, ret.r, ret.s, ret.v, newOffset) =\n      decodeGuardianSignatureCdUnchecked(encodedVaa, offset);\n  }\n\n  function decodeGuardianSignatureMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (\n    uint8 guardianIndex,\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    uint newOffset\n  ) { unchecked {\n    (guardianIndex, offset) = encoded.asUint8MemUnchecked(offset);\n    (r,             offset) = encoded.asBytes32MemUnchecked(offset);\n    (s,             offset) = encoded.asBytes32MemUnchecked(offset);\n    (v,             offset) = encoded.asUint8MemUnchecked(offset);\n    v += SIGNATURE_RECOVERY_MAGIC;\n    newOffset = offset;\n  }}\n\n  function decodeGuardianSignatureStructMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (GuardianSignature memory ret, uint newOffset) {\n    (ret.guardianIndex, ret.r, ret.s, ret.v, newOffset) =\n      decodeGuardianSignatureMemUnchecked(encoded, offset);\n  }\n\n  function decodeVaaPayloadCd(\n    bytes calldata encodedVaa,\n    uint payloadOffset\n  ) internal pure returns (bytes calldata payload) {\n    payload = _decodeRemainderCd(encodedVaa, payloadOffset);\n  }\n\n  function decodeVaaPayloadMemUnchecked(\n    bytes memory encoded,\n    uint payloadOffset,\n    uint vaaLength\n  ) internal pure returns (bytes memory payload, uint newOffset) { unchecked {\n    //check to avoid underflow in following subtraction\n    payloadOffset.checkBound(vaaLength);\n    (payload, newOffset) = encoded.sliceMemUnchecked(payloadOffset, vaaLength - payloadOffset);\n  }}\n\n  // ------------ Encoding ------------\n\n  function encode(IWormhole.VM memory vm) internal pure returns (bytes memory) { unchecked {\n    require(vm.version == HEADER_VERSION, \"Invalid version\");\n    return abi.encodePacked(\n      encodeVaaHeader(vm.guardianSetIndex, asGuardianSignatures(vm.signatures)),\n      vm.timestamp,\n      vm.nonce,\n      vm.emitterChainId,\n      vm.emitterAddress,\n      vm.sequence,\n      vm.consistencyLevel,\n      vm.payload\n    );\n  }}\n\n  function encodeVaaHeader(\n    uint32 guardianSetIndex,\n    GuardianSignature[] memory signatures\n  ) internal pure returns (bytes memory) {\n    bytes memory sigs;\n    for (uint i = 0; i < signatures.length; ++i) {\n      GuardianSignature memory sig = signatures[i];\n      uint8 v = sig.v - SIGNATURE_RECOVERY_MAGIC; //deliberately checked\n      sigs = bytes.concat(sigs, abi.encodePacked(sig.guardianIndex, sig.r, sig.s, v));\n    }\n\n    return abi.encodePacked(\n      HEADER_VERSION,\n      guardianSetIndex,\n      uint8(signatures.length),\n      sigs\n    );\n  }\n\n  function encode(VaaHeader memory header) internal pure returns (bytes memory) {\n    return encodeVaaHeader(header.guardianSetIndex, header.signatures);\n  }\n\n  function encodeVaaEnvelope(\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(\n      timestamp,\n      nonce,\n      emitterChainId,\n      emitterAddress,\n      sequence,\n      consistencyLevel\n    );\n  }\n\n  function encode(VaaEnvelope memory envelope) internal pure returns (bytes memory) {\n    return encodeVaaEnvelope(\n      envelope.timestamp,\n      envelope.nonce,\n      envelope.emitterChainId,\n      envelope.emitterAddress,\n      envelope.sequence,\n      envelope.consistencyLevel\n    );\n  }\n\n  function encodeVaaBody(\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    bytes memory payload\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(\n      encodeVaaEnvelope(\n        timestamp,\n        nonce,\n        emitterChainId,\n        emitterAddress,\n        sequence,\n        consistencyLevel\n      ),\n      payload\n    );\n  }\n\n  function encode(VaaBody memory body) internal pure returns (bytes memory) {\n    return abi.encodePacked(encode(body.envelope), body.payload);\n  }\n\n  function encodeVaa(\n    uint32 guardianSetIndex,\n    GuardianSignature[] memory signatures,\n    uint32  timestamp,\n    uint32  nonce,\n    uint16  emitterChainId,\n    bytes32 emitterAddress,\n    uint64  sequence,\n    uint8   consistencyLevel,\n    bytes memory payload\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(\n      encodeVaaHeader(guardianSetIndex, signatures),\n      encodeVaaBody(\n        timestamp,\n        nonce,\n        emitterChainId,\n        emitterAddress,\n        sequence,\n        consistencyLevel,\n        payload\n      )\n    );\n  }\n\n  function encode(Vaa memory vaa) internal pure returns (bytes memory) {\n    return encodeVaa(\n      vaa.header.guardianSetIndex,\n      vaa.header.signatures,\n      vaa.envelope.timestamp,\n      vaa.envelope.nonce,\n      vaa.envelope.emitterChainId,\n      vaa.envelope.emitterAddress,\n      vaa.envelope.sequence,\n      vaa.envelope.consistencyLevel,\n      vaa.payload\n    );\n  }\n\n  // ------------ Private ------------\n\n  //we use this function over encodedVaa[offset:] to consistently get BytesParsing errors\n  function _decodeRemainderCd(\n    bytes calldata encodedVaa,\n    uint offset\n  ) private pure returns (bytes calldata remainder) { unchecked {\n    //check to avoid underflow in following subtraction\n    offset.checkBound(encodedVaa.length);\n    (remainder, ) = encodedVaa.sliceCdUnchecked(offset, encodedVaa.length - offset);\n  }}\n}\n\nusing VaaLib for VaaHeader global;\nusing VaaLib for VaaEnvelope global;\nusing VaaLib for VaaBody global;\nusing VaaLib for Vaa global;\n"
    },
    "lib/wormhole-solidity-sdk/src/libraries/TokenBridgeMessages.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.14; //for (bugfixed) support of `using ... global;` syntax for libraries\n\nimport {WORD_SIZE} from \"wormhole-sdk/constants/Common.sol\";\nimport {BytesParsing} from \"wormhole-sdk/libraries/BytesParsing.sol\";\n\n// ╭─────────────────────────────────────────────────────────────╮\n// │ Library for encoding and decoding Wormhole TokenBridge VAAs │\n// ╰─────────────────────────────────────────────────────────────╯\n\n// # Payload Formats\n//\n// see:\n//   * [TokenBridge](https://github.com/wormhole-foundation/wormhole/blob/1dbe8459b96e182932d0dd5ae4b6bbce6f48cb09/ethereum/contracts/bridge/Bridge.sol#L595-L629)\n//   * [Typescript SDK](https://github.com/wormhole-foundation/wormhole-sdk-ts/blob/main/core/definitions/src/protocols/tokenBridge/tokenBridgeLayout.ts)\n//\n// ╭────────────┬──────────────────┬────────────────────────────────────────────────────────╮\n// │    Type    │       Name       │     Description                                        │\n// ┝━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │       CommonTransferHeader (shared by Transfer and TransferWithPayload)                │\n// ├────────────┬──────────────────┬────────────────────────────────────────────────────────┤\n// │  uint8     │ payloadId        │ either 1 or 3 (see PAYLOAD_ID constants below)         │\n// │  uint256   │ normalizedAmount │ amount of transferred tokens truncated to 8 decimals   │\n// │  bytes32   │ tokenAddress     │ address of the token on the origin chain               │\n// │  uint16    │ tokenChainId     │ Wormhole chain id of the token's origin chain          │\n// │  bytes32   │ toAddress        │ address of the recipient on the destination chain      │\n// │  uint16    │ toChainId        │ Wormhole chain id of the destination chain             │\n// ┝━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │        Transfer                                                                        │\n// ├────────────────────────────────────────────────────────────────────────────────────────┤\n// │  CommonTransferHeader                                                                  │\n// ├╌╌╌╌╌╌╌╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤\n// │  uint256   │ fee              │ ignored/unused legacy field, should always be 0        │\n// ┝━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │        TransferWithPayload                                                             │\n// ├────────────────────────────────────────────────────────────────────────────────────────┤\n// │  CommonTransferHeader                                                                  │\n// ├╌╌╌╌╌╌╌╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤\n// │  bytes32   │ fromAddress      │ address of the sender on the origin chain              │\n// │  bytes     │ payload          │ additional payload of the transfer                     │\n// ┝━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥\n// │        AttestMeta                                                                      │\n// ├────────────┬──────────────────┬────────────────────────────────────────────────────────┤\n// │  uint8     │ payloadId        │ fixed value: 2 (see PAYLOAD_ID_ATTEST_META below)      │\n// │  bytes32   │ tokenAddress     │ address of the token on the origin chain               │\n// │  uint16    │ tokenChainId     │ Wormhole chain id of the origin chain                  │\n// │  uint8     │ decimals         │ number of decimals of the token                        │\n// │  bytes32   │ symbol           │ symbol of the token                                    │\n// │  bytes32   │ name             │ name of the token                                      │\n// ╰────────────┴──────────────────┴────────────────────────────────────────────────────────╯\n//\n// # Library Functions & Naming Conventions\n//\n// All decode library functions come in 2x2=4 flavors:\n//   1. Data-Location:\n//     1.1. Calldata (using the Cd tag)\n//     1.2. Memory (using the Mem tag)\n//   2. Return Value:\n//     2.1. individual, stack-based return values (no extra tag)\n//     2.2. the associated, memory-allocated Struct (using the Struct tag)\n//\n// Additionally, like in BytesParsing, the Unchecked function name suffix does not refer to\n//   Solidity's `unchecked` keyword, but rather to the fact that no bounds checking is performed.\n//\n// Decoding functions flavorless base names:\n//   * decodeTransfer\n//   * decodeTransferWithPayload\n//   * decodeAttestMeta\n//\n// Encoding functions (should only be relevant for testing):\n//   * encode (overloaded for each struct)\n//   * encodeTransfer\n//   * encodeTransferWithPayload\n//   * encodeAttestMeta\n//\n// Other functions:\n//   * checkPayloadId\n\nstruct TokenBridgeTransfer {\n  //uint8 payloadId; //see PAYLOAD_ID_TRANSFER\n  uint256 normalizedAmount;\n  bytes32 tokenAddress;\n  uint16  tokenChainId;\n  bytes32 toAddress;\n  uint16  toChainId;\n  //uint256 fee; //discarded\n}\n\nstruct TokenBridgeTransferWithPayload {\n  //uint8 payloadId; //see PAYLOAD_ID_TRANSFER_WITH_PAYLOAD\n  uint256 normalizedAmount;\n  bytes32 tokenAddress;\n  uint16  tokenChainId;\n  bytes32 toAddress;\n  uint16  toChainId;\n  bytes32 fromAddress;\n  bytes   payload;\n}\n\nstruct TokenBridgeTransferWithPayloadEssentials {\n  //uint8 payloadId; //see PAYLOAD_ID_TRANSFER_WITH_PAYLOAD\n  uint256 normalizedAmount;\n  bytes32 tokenAddress;\n  uint16  tokenChainId;\n  bytes32 fromAddress;\n  bytes   payload;\n}\n\nstruct TokenBridgeAttestMeta {\n  //uint8 payloadId; //see PAYLOAD_ID_ATTEST_META\n  bytes32 tokenAddress;\n  uint16  tokenChainId;\n  uint8   decimals;\n  bytes32 symbol;\n  bytes32 name;\n}\n\nlibrary TokenBridgeMessageLib {\n  using BytesParsing for bytes;\n  using {BytesParsing.checkBound, BytesParsing.checkLength} for uint;\n\n  error InvalidPayloadId(uint8 encoded);\n\n  //constants are provided to allow more eclectic, manual decoding\n  uint8 internal constant PAYLOAD_ID_TRANSFER = 1;\n  uint8 internal constant PAYLOAD_ID_TRANSFER_WITH_PAYLOAD = 3;\n  uint8 internal constant PAYLOAD_ID_ATTEST_META = 2;\n\n  uint internal constant PAYLOAD_ID_OFFSET = 0;\n  uint internal constant PAYLOAD_ID_SIZE = 1;\n\n  // Common Transfer format offsets and sizes\n  uint internal constant COMMON_TRANSFER_AMOUNT_OFFSET =\n    PAYLOAD_ID_OFFSET + PAYLOAD_ID_SIZE;\n  uint internal constant COMMON_TRANSFER_AMOUNT_SIZE = 32;\n\n  uint internal constant COMMON_TRANSFER_TOKEN_ADDRESS_OFFSET =\n    COMMON_TRANSFER_AMOUNT_OFFSET + COMMON_TRANSFER_AMOUNT_SIZE;\n  uint internal constant COMMON_TRANSFER_TOKEN_ADDRESS_SIZE = 32;\n\n  uint internal constant COMMON_TRANSFER_TOKEN_CHAIN_ID_OFFSET =\n    COMMON_TRANSFER_TOKEN_ADDRESS_OFFSET + COMMON_TRANSFER_TOKEN_ADDRESS_SIZE;\n  uint internal constant COMMON_TRANSFER_TOKEN_CHAIN_ID_SIZE = 2;\n\n  uint internal constant COMMON_TRANSFER_TO_ADDRESS_OFFSET =\n    COMMON_TRANSFER_TOKEN_CHAIN_ID_OFFSET + COMMON_TRANSFER_TOKEN_CHAIN_ID_SIZE;\n  uint internal constant COMMON_TRANSFER_TO_ADDRESS_SIZE = 32;\n\n  uint internal constant COMMON_TRANSFER_TO_CHAIN_ID_OFFSET =\n    COMMON_TRANSFER_TO_ADDRESS_OFFSET + COMMON_TRANSFER_TO_ADDRESS_SIZE;\n  uint internal constant COMMON_TRANSFER_TO_CHAIN_ID_SIZE = 2;\n\n  uint internal constant COMMON_TRANSFER_SIZE =\n    COMMON_TRANSFER_TO_CHAIN_ID_OFFSET + COMMON_TRANSFER_TO_CHAIN_ID_SIZE;\n\n  // Additional Transfer fields\n  uint internal constant TRANSFER_FEE_OFFSET = COMMON_TRANSFER_SIZE;\n  uint internal constant TRANSFER_FEE_SIZE = 32;\n  uint internal constant TRANSFER_SIZE =\n    TRANSFER_FEE_OFFSET + TRANSFER_FEE_SIZE;\n\n  // Additional TransferWithPayload fields\n  uint internal constant TRANSFER_WITH_PAYLOAD_FROM_ADDRESS_OFFSET = COMMON_TRANSFER_SIZE;\n  uint internal constant TRANSFER_WITH_PAYLOAD_FROM_ADDRESS_SIZE = 32;\n\n  uint internal constant TRANSFER_WITH_PAYLOAD_PAYLOAD_OFFSET = //only a mother can love this name\n    TRANSFER_WITH_PAYLOAD_FROM_ADDRESS_OFFSET + TRANSFER_WITH_PAYLOAD_FROM_ADDRESS_SIZE;\n\n  // AttestMeta format offsets and sizes\n  uint internal constant ATTEST_META_TOKEN_ADDRESS_OFFSET =\n    PAYLOAD_ID_OFFSET + PAYLOAD_ID_SIZE;\n  uint internal constant ATTEST_META_TOKEN_ADDRESS_SIZE = 32;\n\n  uint internal constant ATTEST_META_TOKEN_CHAIN_ID_OFFSET =\n    ATTEST_META_TOKEN_ADDRESS_OFFSET + ATTEST_META_TOKEN_ADDRESS_SIZE;\n  uint internal constant ATTEST_META_TOKEN_CHAIN_ID_SIZE = 2;\n\n  uint internal constant ATTEST_META_DECIMALS_OFFSET =\n    ATTEST_META_TOKEN_CHAIN_ID_OFFSET + ATTEST_META_TOKEN_CHAIN_ID_SIZE;\n  uint internal constant ATTEST_META_DECIMALS_SIZE = 1;\n\n  uint internal constant ATTEST_META_SYMBOL_OFFSET =\n    ATTEST_META_DECIMALS_OFFSET + ATTEST_META_DECIMALS_SIZE;\n  uint internal constant ATTEST_META_SYMBOL_SIZE = 32;\n\n  uint internal constant ATTEST_META_NAME_OFFSET =\n    ATTEST_META_SYMBOL_OFFSET + ATTEST_META_SYMBOL_SIZE;\n  uint internal constant ATTEST_META_NAME_SIZE = 32;\n\n  uint internal constant ATTEST_META_SIZE =\n    ATTEST_META_NAME_OFFSET + ATTEST_META_NAME_SIZE;\n\n  // ------------ Decoding ------------\n\n  function checkPayloadId(uint8 encoded, uint8 expected) internal pure {\n    if (encoded != expected)\n      revert InvalidPayloadId(encoded);\n  }\n\n  // Transfer\n\n  function decodeTransferCd(\n    bytes calldata encoded\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId\n  ) {\n    uint offset = 0;\n    (normalizedAmount, tokenAddress, tokenChainId, toAddress, toChainId, offset) =\n      _decodeTransferCommonHeaderCdUnchecked(encoded, PAYLOAD_ID_TRANSFER);\n\n    offset += WORD_SIZE;\n    encoded.length.checkLength(offset);\n  }\n\n  function decodeTransferStructCd(\n    bytes calldata encoded\n  ) internal pure returns (TokenBridgeTransfer memory transfer) {\n    ( transfer.normalizedAmount,\n      transfer.tokenAddress,\n      transfer.tokenChainId,\n      transfer.toAddress,\n      transfer.toChainId\n    ) = decodeTransferCd(encoded);\n  }\n\n  function decodeTransferMem(\n    bytes memory encoded\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId\n  ) {\n    uint offset = 0;\n    (normalizedAmount, tokenAddress, tokenChainId, toAddress, toChainId, offset) =\n      decodeTransferMemUnchecked(encoded, offset);\n    encoded.length.checkLength(offset);\n  }\n\n  function decodeTransferStructMem(\n    bytes memory encoded\n  ) internal pure returns (TokenBridgeTransfer memory transfer) {\n    ( transfer.normalizedAmount,\n      transfer.tokenAddress,\n      transfer.tokenChainId,\n      transfer.toAddress,\n      transfer.toChainId\n    ) = decodeTransferMem(encoded);\n  }\n\n  function decodeTransferMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId,\n    uint    newOffset\n  ) {\n    (normalizedAmount, tokenAddress, tokenChainId, toAddress, toChainId, offset) =\n      _decodeTransferCommonHeaderMemUnchecked(encoded, offset, PAYLOAD_ID_TRANSFER);\n\n    offset += WORD_SIZE;\n    newOffset = offset;\n  }\n\n  function decodeTransferStructMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (TokenBridgeTransfer memory transfer, uint newOffset) {\n    ( transfer.normalizedAmount,\n      transfer.tokenAddress,\n      transfer.tokenChainId,\n      transfer.toAddress,\n      transfer.toChainId,\n      newOffset\n    ) = decodeTransferMemUnchecked(encoded, offset);\n  }\n\n  // TransferWithPayload\n\n  function decodeTransferWithPayloadCd(\n    bytes calldata encoded\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId,\n    bytes32 fromAddress,\n    bytes calldata payload\n  ) { unchecked {\n    uint offset = 0;\n    (normalizedAmount, tokenAddress, tokenChainId, toAddress, toChainId, offset) =\n      _decodeTransferCommonHeaderCdUnchecked(encoded, PAYLOAD_ID_TRANSFER_WITH_PAYLOAD);\n\n    (fromAddress, offset) = encoded.asBytes32CdUnchecked(offset);\n\n    offset.checkBound(encoded.length); //check for underflow\n    (payload, ) = encoded.sliceCdUnchecked(offset, encoded.length - offset);\n  }}\n\n  function decodeTransferWithPayloadStructCd(\n    bytes calldata encoded\n  ) internal pure returns (TokenBridgeTransferWithPayload memory twp) {\n    ( twp.normalizedAmount,\n      twp.tokenAddress,\n      twp.tokenChainId,\n      twp.toAddress,\n      twp.toChainId,\n      twp.fromAddress,\n      twp.payload\n    ) = decodeTransferWithPayloadCd(encoded);\n  }\n\n  function decodeTransferWithPayloadMem(\n    bytes memory encoded\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId,\n    bytes32 fromAddress,\n    bytes memory payload\n  ) {\n    (normalizedAmount, tokenAddress, tokenChainId, toAddress, toChainId, fromAddress, payload, ) =\n      decodeTransferWithPayloadMem(encoded, 0, encoded.length);\n  }\n\n  function decodeTransferWithPayloadStructMem(\n    bytes memory encoded\n  ) internal pure returns (TokenBridgeTransferWithPayload memory twp) {\n    (twp, ) = decodeTransferWithPayloadStructMem(encoded, 0, encoded.length);\n  }\n\n  function decodeTransferWithPayloadMem(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId,\n    bytes32 fromAddress,\n    bytes memory payload,\n    uint    newOffset\n  ) { unchecked {\n    (normalizedAmount, tokenAddress, tokenChainId, toAddress, toChainId, offset) =\n      _decodeTransferCommonHeaderMemUnchecked(encoded, offset, PAYLOAD_ID_TRANSFER_WITH_PAYLOAD);\n\n    (fromAddress, offset) = encoded.asBytes32MemUnchecked(offset);\n\n    offset.checkBound(length); //check for underflow\n    (payload, newOffset) = encoded.sliceMemUnchecked(offset, length - offset);\n\n  }}\n\n  function decodeTransferWithPayloadStructMem(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (TokenBridgeTransferWithPayload memory twp, uint newOffset) {\n    ( twp.normalizedAmount,\n      twp.tokenAddress,\n      twp.tokenChainId,\n      twp.toAddress,\n      twp.toChainId,\n      twp.fromAddress,\n      twp.payload,\n      newOffset\n    ) = decodeTransferWithPayloadMem(encoded, offset, length);\n  }\n\n  // TransferWithPayloadEssentials\n\n  function decodeTransferWithPayloadEssentialsCd(\n    bytes calldata encoded\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 fromAddress,\n    bytes calldata payload\n  ) { unchecked {\n    uint offset = 0;\n    (normalizedAmount, tokenAddress, tokenChainId, offset) =\n      _decodeTransferCommonHeaderEssentialsCdUnchecked(encoded, PAYLOAD_ID_TRANSFER_WITH_PAYLOAD);\n    \n    offset += COMMON_TRANSFER_TO_ADDRESS_SIZE + COMMON_TRANSFER_TO_CHAIN_ID_SIZE;\n    (fromAddress, offset) = encoded.asBytes32CdUnchecked(offset);\n\n    offset.checkBound(encoded.length); //check for underflow\n    (payload, ) = encoded.sliceCdUnchecked(offset, encoded.length - offset);\n  }}\n\n  function decodeTransferWithPayloadEssentialsStructCd(\n    bytes calldata encoded\n  ) internal pure returns (TokenBridgeTransferWithPayloadEssentials memory twp) {\n    ( twp.normalizedAmount,\n      twp.tokenAddress,\n      twp.tokenChainId,\n      twp.fromAddress,\n      twp.payload\n    ) = decodeTransferWithPayloadEssentialsCd(encoded);\n  }\n\n  function decodeTransferWithPayloadEssentialsMem(\n    bytes memory encoded\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 fromAddress,\n    bytes memory payload\n  ) {\n    (normalizedAmount, tokenAddress, tokenChainId, fromAddress, payload, ) =\n      decodeTransferWithPayloadEssentialsMem(encoded, 0, encoded.length);\n  }\n\n  function decodeTransferWithPayloadEssentialsStructMem(\n    bytes memory encoded\n  ) internal pure returns (TokenBridgeTransferWithPayloadEssentials memory twp) {\n    (twp, ) = decodeTransferWithPayloadEssentialsStructMem(encoded, 0, encoded.length);\n  }\n\n  function decodeTransferWithPayloadEssentialsMem(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 fromAddress,\n    bytes memory payload,\n    uint    newOffset\n  ) { unchecked {\n    (normalizedAmount, tokenAddress, tokenChainId, offset) =\n      _decodeTransferCommonHeaderEssentialsMemUnchecked(encoded, offset, PAYLOAD_ID_TRANSFER_WITH_PAYLOAD);\n\n    offset += COMMON_TRANSFER_TO_ADDRESS_SIZE + COMMON_TRANSFER_TO_CHAIN_ID_SIZE;\n    (fromAddress, offset) = encoded.asBytes32MemUnchecked(offset);\n\n    offset.checkBound(length); //check for underflow\n    (payload, newOffset) = encoded.sliceMemUnchecked(offset, length - offset);\n\n  }}\n\n  function decodeTransferWithPayloadEssentialsStructMem(\n    bytes memory encoded,\n    uint offset,\n    uint length\n  ) internal pure returns (TokenBridgeTransferWithPayloadEssentials memory twp, uint newOffset) {\n    ( twp.normalizedAmount,\n      twp.tokenAddress,\n      twp.tokenChainId,\n      twp.fromAddress,\n      twp.payload,\n      newOffset\n    ) = decodeTransferWithPayloadEssentialsMem(encoded, offset, length);\n  }\n\n  // AttestMeta\n\n  function decodeAttestMetaCd(\n    bytes calldata encoded\n  ) internal pure returns (\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    uint8   decimals,\n    bytes32 symbol,\n    bytes32 name\n  ) {\n    uint offset = 0;\n    uint8 payloadId;\n    (payloadId,    offset) = encoded.asUint8CdUnchecked(offset);\n    checkPayloadId(payloadId, PAYLOAD_ID_ATTEST_META);\n    (tokenAddress, offset) = encoded.asBytes32CdUnchecked(offset);\n    (tokenChainId, offset) = encoded.asUint16CdUnchecked(offset);\n    (decimals,     offset) = encoded.asUint8CdUnchecked(offset);\n    (symbol,       offset) = encoded.asBytes32CdUnchecked(offset);\n    (name,         offset) = encoded.asBytes32CdUnchecked(offset);\n    encoded.length.checkLength(offset);\n  }\n\n  function decodeAttestMetaStructCd(\n    bytes calldata encoded\n  ) internal pure returns (TokenBridgeAttestMeta memory attestMeta) {\n    ( attestMeta.tokenAddress,\n      attestMeta.tokenChainId,\n      attestMeta.decimals,\n      attestMeta.symbol,\n      attestMeta.name\n    ) = decodeAttestMetaCd(encoded);\n  }\n\n  function decodeAttestMetaMem(\n    bytes memory encoded\n  ) internal pure returns (\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    uint8   decimals,\n    bytes32 symbol,\n    bytes32 name\n  ) {\n    uint offset = 0;\n    (tokenAddress, tokenChainId, decimals, symbol, name, offset) =\n      decodeAttestMetaMemUnchecked(encoded, offset);\n    encoded.length.checkLength(offset);\n  }\n\n  function decodeAttestMetaStructMem(\n    bytes memory encoded\n  ) internal pure returns (TokenBridgeAttestMeta memory attestMeta) {\n    (attestMeta, ) = decodeAttestMetaStructMemUnchecked(encoded, 0);\n  }\n\n  function decodeAttestMetaMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    uint8   decimals,\n    bytes32 symbol,\n    bytes32 name,\n    uint    newOffset\n  ) {\n    uint8 payloadId;\n    (payloadId,    offset) = encoded.asUint8MemUnchecked(offset);\n    checkPayloadId(payloadId, PAYLOAD_ID_ATTEST_META);\n    (tokenAddress, offset) = encoded.asBytes32MemUnchecked(offset);\n    (tokenChainId, offset) = encoded.asUint16MemUnchecked(offset);\n    (decimals,     offset) = encoded.asUint8MemUnchecked(offset);\n    (symbol,       offset) = encoded.asBytes32MemUnchecked(offset);\n    (name,         offset) = encoded.asBytes32MemUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function decodeAttestMetaStructMemUnchecked(\n    bytes memory encoded,\n    uint offset\n  ) internal pure returns (TokenBridgeAttestMeta memory attestMeta, uint newOffset) {\n    ( attestMeta.tokenAddress,\n      attestMeta.tokenChainId,\n      attestMeta.decimals,\n      attestMeta.symbol,\n      attestMeta.name,\n      newOffset\n    ) = decodeAttestMetaMemUnchecked(encoded, offset);\n  }\n\n  // ------------ Encoding ------------\n\n  function encodeTransfer(\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId\n  ) internal pure returns (bytes memory encoded) {\n    return abi.encodePacked(\n      PAYLOAD_ID_TRANSFER,\n      normalizedAmount,\n      tokenAddress,\n      tokenChainId,\n      toAddress,\n      toChainId,\n      uint256(0) //add otherwise discarded fee field\n    );\n  }\n\n  function encode(TokenBridgeTransfer memory transfer) internal pure returns (bytes memory) {\n    return encodeTransfer(\n      transfer.normalizedAmount,\n      transfer.tokenAddress,\n      transfer.tokenChainId,\n      transfer.toAddress,\n      transfer.toChainId\n    );\n  }\n\n  function encodeTransferWithPayload(\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId,\n    bytes32 fromAddress,\n    bytes memory payload\n  ) internal pure returns (bytes memory encoded) {\n    return abi.encodePacked(\n      PAYLOAD_ID_TRANSFER_WITH_PAYLOAD,\n      normalizedAmount,\n      tokenAddress,\n      tokenChainId,\n      toAddress,\n      toChainId,\n      fromAddress,\n      payload\n    );\n  }\n\n  function encode(TokenBridgeTransferWithPayload memory twp) internal pure returns (bytes memory) {\n    return encodeTransferWithPayload(\n      twp.normalizedAmount,\n      twp.tokenAddress,\n      twp.tokenChainId,\n      twp.toAddress,\n      twp.toChainId,\n      twp.fromAddress,\n      twp.payload\n    );\n  }\n\n  function encodeAttestMeta(\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    uint8   decimals,\n    bytes32 symbol,\n    bytes32 name\n  ) internal pure returns (bytes memory encoded) {\n    return abi.encodePacked(\n      PAYLOAD_ID_ATTEST_META,\n      tokenAddress,\n      tokenChainId,\n      decimals,\n      symbol,\n      name\n    );\n  }\n\n  function encode(TokenBridgeAttestMeta memory attestMeta) internal pure returns (bytes memory) {\n    return encodeAttestMeta(\n      attestMeta.tokenAddress,\n      attestMeta.tokenChainId,\n      attestMeta.decimals,\n      attestMeta.symbol,\n      attestMeta.name\n    );\n  }\n\n  // ------------ Private ------------\n\n  function _decodeTransferCommonHeaderEssentialsCdUnchecked(\n    bytes calldata encoded,\n    uint8 expectedPayloadId\n  ) private pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    uint    newOffset\n  ) {\n    uint8 payloadId;\n    uint offset = 0;\n    (payloadId,        offset) = encoded.asUint8CdUnchecked(offset);\n    checkPayloadId(payloadId, expectedPayloadId);\n    (normalizedAmount, offset) = encoded.asUint256CdUnchecked(offset);\n    (tokenAddress,     offset) = encoded.asBytes32CdUnchecked(offset);\n    (tokenChainId,     offset) = encoded.asUint16CdUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function _decodeTransferCommonHeaderEssentialsMemUnchecked(\n    bytes memory encoded,\n    uint offset,\n    uint8 expectedPayloadId\n  ) private pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    uint    newOffset\n  ) {\n    uint8 payloadId;\n    (payloadId,        offset) = encoded.asUint8MemUnchecked(offset);\n    checkPayloadId(payloadId, expectedPayloadId);\n    (normalizedAmount, offset) = encoded.asUint256MemUnchecked(offset);\n    (tokenAddress,     offset) = encoded.asBytes32MemUnchecked(offset);\n    (tokenChainId,     offset) = encoded.asUint16MemUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function _decodeTransferCommonHeaderCdUnchecked(\n    bytes calldata encoded,\n    uint8 expectedPayloadId\n  ) private pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId,\n    uint    newOffset\n  ) {\n    uint offset;\n    (\n      normalizedAmount,\n      tokenAddress,\n      tokenChainId,\n      offset\n    ) = _decodeTransferCommonHeaderEssentialsCdUnchecked(encoded, expectedPayloadId);\n    (toAddress, offset) = encoded.asBytes32CdUnchecked(offset);\n    (toChainId, offset) = encoded.asUint16CdUnchecked(offset);\n    newOffset = offset;\n  }\n\n  function _decodeTransferCommonHeaderMemUnchecked(\n    bytes memory encoded,\n    uint offset,\n    uint8 expectedPayloadId\n  ) private pure returns (\n    uint256 normalizedAmount,\n    bytes32 tokenAddress,\n    uint16  tokenChainId,\n    bytes32 toAddress,\n    uint16  toChainId,\n    uint    newOffset\n  ) {\n    (\n      normalizedAmount,\n      tokenAddress,\n      tokenChainId,\n      offset\n    ) = _decodeTransferCommonHeaderEssentialsMemUnchecked(encoded, offset, expectedPayloadId);\n    (toAddress, offset) = encoded.asBytes32MemUnchecked(offset);\n    (toChainId, offset) = encoded.asUint16MemUnchecked(offset);\n    newOffset = offset;\n  }\n}\n\nusing TokenBridgeMessageLib for TokenBridgeTransfer global;\nusing TokenBridgeMessageLib for TokenBridgeTransferWithPayload global;\nusing TokenBridgeMessageLib for TokenBridgeAttestMeta global;\n"
    },
    "../lib/relayer-infra-contracts/apps/price-oracle/evm/src/assets/types/ParamLibs.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// !!! All unit libs return prices via their `from` functions as fixed point uints !!!\n// !!!   with 18 decimals in \"human units\" (i.e. eth, not wei, sol, not lamports). !!!\n// !!! So if 1 eth = $1000, then GasTokenPrice.from() returns 1e21 [usd/gasToken]. !!!\n// !!! Likewise, `to` functions expect prices in the same format.                  !!!\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n// Summary (since most of this file is boilerplate):\n//\n//      Type               │ External Repr │ Internal Repr │ Bytes\n//─────────────────────────┼───────────────┼───────────────┼───────\n//  GasTokenPrice          │ usd/gasToken  │ µusd/gasToken │   6\n//     GasPrice            │ gasToken/gas  │   Mwei/gas    │   4\n//  PricePerTxByte         │ gasToken/byte │   Mwei/byte   │   4\n// SolanaComputationPrice  │    sol/cu     │ µlamports/cu  │   4\n// PricePerAccountByte     │   sol/byte    │ lamports/byte │   4\n//  SignaturePrice         │    sol/sig    │ lamports/sig  │   4\n//    GasDropoff           │   gasToken    │   µgasToken   │   4\n//     BaseFee             │      usd      │     µusd      │   4\n// SuiComputationPrice     │    sui/cu     │    mist/cu    │   4\n//   StoragePrice          │    sui/byte   │   mist/byte   │   4\n//  StorageRebate          │  percentage   │    0 to 100   │   1\n\nerror LosingAllPrecision(uint256 , uint256 divisor);\nerror ExceedsMax(uint256 stored, uint256 max);\n\nfunction checkedUnitDiv(uint val, uint divisor, uint max) pure returns (uint) { unchecked {\n  if (val == 0)\n    return 0;\n\n  uint ret = val / divisor;\n  if (ret == 0)\n    revert LosingAllPrecision(val, divisor);\n\n  if (ret > max)\n    revert ExceedsMax(ret, max);\n\n  return ret;\n}}\n\n//gasToken is a more general term for elements of the set {sol, eth, avax, ...}\ntype GasTokenPrice is uint48;\n//external repr: usd/gasToken with 18 decimals (1 usd/eth => 1e18, usd NOT µusd!)\nlibrary GasTokenPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 6;\n  uint private constant UNIT = 1e12; //µusd/gasToken (1e6 * 1e12 = 1e18)\n\n  function to(uint val) internal pure returns (GasTokenPrice) {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint48).max);\n\n    //skip unneccessary cleanup\n    uint48 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return GasTokenPrice.wrap(ret);\n  }\n\n  function from(GasTokenPrice val) internal pure returns (uint) { unchecked {\n    return uint(GasTokenPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing GasTokenPriceLib for GasTokenPrice global;\n\n//cost of 1 consumed gas unit\ntype GasPrice is uint32;\n//external repr: gasToken/gas with 18 decimals (eth/gas NOT Gwei/gas!)\nlibrary GasPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e6;\n\n  function to(uint val) internal pure returns (GasPrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return GasPrice.wrap(ret);\n  }}\n\n  function from(GasPrice val) internal pure returns (uint) { unchecked {\n    return uint(GasPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing GasPriceLib for GasPrice global;\n\n//per byte cost of calldata on L2s\ntype PricePerTxByte is uint32;\n//external repr: gasToken/byte (of calldata) with 18 decimals (eth/byte NOT Gwei/gas!)\nlibrary PricePerTxByteLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e6;\n\n  function to(uint val) internal pure returns (PricePerTxByte) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return PricePerTxByte.wrap(ret);\n  }}\n\n  function from(PricePerTxByte val) internal pure returns (uint) { unchecked {\n    return uint(PricePerTxByte.unwrap(val)) * UNIT;\n  }\n}}\nusing PricePerTxByteLib for PricePerTxByte global;\n\n// The price of a computation unit on the Solana chain\ntype SolanaComputationPrice is uint32;\n// External repr: sol/CU with 18 decimals (NOT lamports/CU!)\nlibrary SolanaComputationPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e3; // Stored in microlamports/CU (15 decimals per CU)\n\n  function to(uint256 val) internal pure returns (SolanaComputationPrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return SolanaComputationPrice.wrap(ret);\n  }}\n\n  function from(SolanaComputationPrice val) internal pure returns (uint256) { unchecked {\n    return uint256(SolanaComputationPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing SolanaComputationPriceLib for SolanaComputationPrice global;\n\n//per byte cost of solana account data\ntype PricePerAccountByte is uint32;\n//external repr: sol/byte (of account data) with 18 decimals (NOT lamports/byte!)\n//At time of writing: 6_960 lamports/byte (alson likely won't change).\n//So likely returned value: 6_960_000_000_000 = 0.00000696 sol/byte\nlibrary PricePerAccountByteLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; //stored in lamports/byte\n\n  function to(uint256 val) internal pure returns (PricePerAccountByte) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return PricePerAccountByte.wrap(ret);\n  }}\n\n  function from(PricePerAccountByte val) internal pure returns (uint256) { unchecked {\n    return uint256(PricePerAccountByte.unwrap(val)) * UNIT;\n  }\n}}\nusing PricePerAccountByteLib for PricePerAccountByte global;\n\n// Cost per signature in Solana\ntype SignaturePrice is uint32;\n//external repr: sol/signature with 18 decimals (NOT lamports/byte!)\n//At time of writing: 10000 lamports per signature\nlibrary SignaturePriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; //stored in lamports/byte\n\n  function to(uint256 val) internal pure returns (SignaturePrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return SignaturePrice.wrap(ret);\n  }}\n\n  function from(SignaturePrice val) internal pure returns (uint256) { unchecked {\n    return uint256(SignaturePrice.unwrap(val)) * UNIT;\n  }\n}}\nusing SignaturePriceLib for SignaturePrice global;\n\n//requested amount of additional gas dropoff for a delivery\ntype GasDropoff is uint32;\n//external repr: gasToken with 18 decimals\nlibrary GasDropoffLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e12; //specified in µgasToken\n\n  function to(uint256 val) internal pure returns (GasDropoff) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return GasDropoff.wrap(ret);\n  }}\n\n  function from(GasDropoff val) internal pure returns (uint256) { unchecked {\n    return uint256(GasDropoff.unwrap(val)) * UNIT;\n  }\n}}\nusing GasDropoffLib for GasDropoff global;\n\ntype BaseFee is uint32;\n//external repr: usd with 18 decimals\nlibrary BaseFeeLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e12; //specified in µusd\n\n  function to(uint256 val) internal pure returns (BaseFee) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return BaseFee.wrap(ret);\n  }}\n\n  function from(BaseFee val) internal pure returns (uint256) { unchecked {\n    return uint256(BaseFee.unwrap(val)) * UNIT;\n  }\n}}\nusing BaseFeeLib for BaseFee global;\n\n// The price of a computation unit on the SUI chain\n// Similarly to EVM, this is the price of a computation unit in MIST\n// It varies depending on the current state of the network\ntype SuiComputationPrice is uint32;\n// External repr: SUI with 18 decimals, not MIST/computationUnit\nlibrary SuiComputationPriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; // Stored in MIST\n\n  function to(uint256 val) internal pure returns (SuiComputationPrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return SuiComputationPrice.wrap(ret);\n  }}\n\n  function from(SuiComputationPrice val) internal pure returns (uint256) { unchecked {\n    return uint256(SuiComputationPrice.unwrap(val)) * UNIT;\n  }\n}}\nusing SuiComputationPriceLib for SuiComputationPrice global;\n\n// The price of a storage byte on the SUI chain\n// This one is set by governance and thus is unlikely to change\ntype StoragePrice is uint32;\n// External repr: SUI with 18 decimals, not MIST/bytes\nlibrary StoragePriceLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 4;\n  uint private constant UNIT = 1e9; // Stored in MIST\n\n  function to(uint256 val) internal pure returns (StoragePrice) { unchecked {\n    uint tmp = checkedUnitDiv(val, UNIT, type(uint32).max);\n\n    //skip unneccessary cleanup\n    uint32 ret;\n    assembly (\"memory-safe\") { ret := tmp }\n\n    return StoragePrice.wrap(ret);\n  }}\n\n  function from(StoragePrice val) internal pure returns (uint256) { unchecked {\n    return uint256(StoragePrice.unwrap(val)) * UNIT;\n  }\n}}\nusing StoragePriceLib for StoragePrice global;\n\n// The percentage of storage rebate between 0 and 100\n// This one is set by governance and thus is unlikely to change\ntype StorageRebate is uint8;\n// External repr: A percentage, ideally an integer number between 0 and 100\nlibrary StorageRebateLib {\n  //WARNING: any changes must be reflected in the typescript SDK!\n  uint internal constant BYTE_SIZE = 1;\n  uint internal constant MAX = 100;\n\n  function to(uint256 val) internal pure returns (StorageRebate) { unchecked {\n    if (val > MAX)\n      revert ExceedsMax(val, MAX);\n\n    //skip unneccessary cleanup\n    uint8 ret;\n    assembly (\"memory-safe\") { ret := val }\n\n    return StorageRebate.wrap(ret);\n  }}\n\n  function from(StorageRebate val) internal pure returns (uint256) { unchecked {\n    return uint256(StorageRebate.unwrap(val));\n  }\n}}\nusing StorageRebateLib for StorageRebate global;"
    },
    "../lib/relayer-infra-contracts/apps/price-oracle/evm/src/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\ninterface IPriceOracle {\n\n  //selector: 00000eb6\n  function exec768() external payable returns (bytes memory);\n\n  //selector: 0008a112\n  function get1959() external view returns (bytes memory);\n\n  //selector: f4189c473\n  function checkedUpgrade(bytes calldata data) external;\n}"
    },
    "../lib/relayer-infra-contracts/apps/price-oracle/evm/src/assets/PriceOracleIds.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.25;\n\n// ----------- Dispatcher Ids -----------\n\nuint8 constant DISPATCHER_PROTOCOL_VERSION0 = 0;\n\n// Execute commands\n\nuint8 constant PRICES_ID = 0x00;\nuint8 constant UPDATE_ASSISTANT_ID = 0x01;\n\n// Query commands\n\nuint8 constant PRICES_QUERIES_ID = 0x80;\nuint8 constant ASSISTANT_ID = 0x81;\n\n// ----------- Prices Ids ---------------\n\n// Execute commands\n\nuint8 constant EVM_FEE_PARAMS_ID = 0x00;\nuint8 constant EVM_GAS_PRICE_ID = 0x01;\nuint8 constant EVM_PRICE_PER_TX_BYTE_ID = 0x02;\nuint8 constant GAS_TOKEN_PRICE_ID = 0x03;\nuint8 constant SOLANA_COMPUTATION_PRICE_ID = 0x04;\nuint8 constant SOLANA_PRICE_PER_ACCOUNT_BYTE_ID = 0x05;\nuint8 constant SOLANA_SIGNATURE_PRICE_ID = 0x06;\nuint8 constant SUI_COMPUTATION_PRICE_ID = 0x07;\nuint8 constant SUI_STORAGE_PRICE_ID = 0x08;\nuint8 constant SUI_STORAGE_REBATE_ID = 0x09;\n\n// Query commands\n\nuint8 constant EVM_TX_QUOTE_ID = 0x80;\nuint8 constant SOLANA_TX_QUOTE_ID = 0x81;\nuint8 constant SUI_TX_QUOTE_ID = 0x82;\n\nuint8 constant QUERY_FEE_PARAMS_ID = 0x90;\nuint8 constant CHAIN_ID_ID = 0x91;\n"
    },
    "lib/wormhole-solidity-sdk/src/utils/Revert.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {WORD_SIZE} from \"wormhole-sdk/constants/Common.sol\";\n\n//bubble up errors from low level calls\nfunction reRevert(bytes memory err) pure {\n  assembly (\"memory-safe\") {\n    revert(add(err, WORD_SIZE), mload(err))\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/utils/UniversalAddress.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nerror NotAnEvmAddress(bytes32);\n\nfunction toUniversalAddress(address addr) pure returns (bytes32 universalAddr) {\n  universalAddr = bytes32(uint256(uint160(addr)));\n}\n\nfunction fromUniversalAddress(bytes32 universalAddr) pure returns (address addr) {\n  if (bytes12(universalAddr) != 0)\n    revert NotAnEvmAddress(universalAddr);\n\n  assembly (\"memory-safe\") {\n    addr := universalAddr\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/utils/Keccak.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.4;\n\nimport {WORD_SIZE, SCRATCH_SPACE_PTR, FREE_MEMORY_PTR} from \"wormhole-sdk/constants/Common.sol\";\n\nfunction keccak256Word(bytes32 word) pure returns (bytes32 hash) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    mstore(SCRATCH_SPACE_PTR, word)\n    hash := keccak256(SCRATCH_SPACE_PTR, WORD_SIZE)\n  }\n}\n\nfunction keccak256SliceUnchecked(\n  bytes memory encoded,\n  uint offset,\n  uint length\n) pure returns (bytes32 hash) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    // The length of the bytes type `length` field is that of a word in memory\n    let ptr := add(add(encoded, offset), WORD_SIZE)\n    hash := keccak256(ptr, length)\n  }\n}\n\nfunction keccak256Cd(\n  bytes calldata encoded\n) pure returns (bytes32 hash) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    let freeMemory := mload(FREE_MEMORY_PTR)\n    calldatacopy(freeMemory, encoded.offset, encoded.length)\n    hash := keccak256(freeMemory, encoded.length)\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/utils/EagerOps.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.4;\n\n//see Optimization.md for rationale on avoiding short-circuiting\nfunction eagerAnd(bool lhs, bool rhs) pure returns (bool ret) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    ret := and(lhs, rhs)\n  }\n}\n\n//see Optimization.md for rationale on avoiding short-circuiting\nfunction eagerOr(bool lhs, bool rhs) pure returns (bool ret) {\n  /// @solidity memory-safe-assembly\n  assembly {\n    ret := or(lhs, rhs)\n  }\n}\n"
    },
    "lib/wormhole-solidity-sdk/src/proxy/Eip1967Implementation.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.24;\n\nstruct ImplementationState {\n  address implementation;\n  bool    initialized;\n}\n\n// we use the designated eip1967 storage slot: keccak256(\"eip1967.proxy.implementation\") - 1\nbytes32 constant IMPLEMENTATION_SLOT =\n  0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\nfunction implementationState() pure returns (ImplementationState storage state) {\n  assembly (\"memory-safe\") { state.slot := IMPLEMENTATION_SLOT }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/",
      "wormhole-sdk/=lib/wormhole-solidity-sdk/src/",
      "tbr/=src/",
      "price-oracle/=../lib/relayer-infra-contracts/apps/price-oracle/evm/src/",
      "permit2/=lib/permit2/src/interfaces/",
      "@openzeppelin/=/app/lib/relayer-infra-contracts/lib/openzeppelin-contracts/",
      "@openzeppelin@4.9.5/=/app/lib/relayer-infra-contracts/node_modules/@openzeppelin/",
      "@solidity-parser/=/app/lib/relayer-infra-contracts/node_modules/@solidity-parser/",
      "IERC20/=lib/wormhole-solidity-sdk/src/interfaces/token/",
      "SafeERC20/=lib/wormhole-solidity-sdk/src/libraries/",
      "ds-test/=/app/lib/relayer-infra-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=/app/lib/relayer-infra-contracts/lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/",
      "openzeppelin-contracts/=/app/lib/relayer-infra-contracts/lib/openzeppelin-contracts/",
      "oracle/=/app/lib/relayer-infra-contracts/apps/oracle/src/",
      "relayer-infra-contracts/=/app/lib/relayer-infra-contracts/src/evm/",
      "solmate/=lib/permit2/lib/solmate/",
      "truffle/=/app/lib/relayer-infra-contracts/node_modules/truffle/",
      "wormhole-solidity-sdk/=lib/wormhole-solidity-sdk/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "evm.bytecode.linkReferences",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap",
          "evm.deployedBytecode.linkReferences",
          "evm.deployedBytecode.immutableReferences",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": true,
    "libraries": {}
  }
}
